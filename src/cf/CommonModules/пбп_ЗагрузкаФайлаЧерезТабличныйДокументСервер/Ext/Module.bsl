// Библиотека проектных подсистем для упрощения разработки архитектуры на 1С: Предприятие 8,
// включая доработку типовых конфигураций.
//
// Copyright First BIT company
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
// URL:    https://github.com/firstBitSportivnaya/PSSL/
//

#Область ПрограммныйИнтерфейс

// Получить параметры чтения файла
//  - НазваниеЛиста - Строка - наименование листа, с которого необходимо выполнить загрузку данных
//  - НомерСтроки - Число - номер первой строки листа, с которой начинается парсинг данных
//  - СопоставлениеПоНаименованию - Булево - если Истина, то колонки макета сопоставляются с табличным документом по
//  наименованию; если Ложь, то сопоставляются в последовательности колонок макета, а наименования игнорируются.
//  - КонвертироватьДаты - Булево - конвертировать значения с типом дата из строки в дату
//
// Возвращаемое значение:
//  Структура - параметры чтения
//
Функция ПолучитьПараметрыЧтенияФайла() Экспорт
	
	ПараметрыЧтения = Новый Структура;
	ПараметрыЧтения.Вставить("НазваниеЛиста", "");
	ПараметрыЧтения.Вставить("НомерСтроки", 0);
	ПараметрыЧтения.Вставить("СопоставлениеПоНаименованию", Ложь);
	ПараметрыЧтения.Вставить("КонвертироватьДаты", Истина);
	
	Возврат ПараметрыЧтения;
	
КонецФункции

// Конвертирует данные табличного документа в таблицу значений по переданному макету
//
// Параметры:
//  АдресВХранилище		 - Строка - Адрес файла во временном хранилище
//  Расширение			 - Строка - Расширение файла (xls, xlsx)
//  Макет				 - ТаблицаЗначений - в таблице указано имя колонок, их тип и поле поиска ссылочного типа
//  ПараметрыЧтения		 - Структура - см. ПолучитьПараметрыЧтенияФайла
// 
// Возвращаемое значение:
//  ТаблицаЗначений - таблица с данными файла
//
Функция КонвертироватьДанныеТабличногоДокументаВТаблицуЗначений(
	АдресВХранилище, Расширение, Макет, ПараметрыЧтения) Экспорт
	
	НазваниеЛиста = ПараметрыЧтения.НазваниеЛиста;
	НомерСтроки = ПараметрыЧтения.НомерСтроки;
	СопоставлениеПоНаименованию = ПараметрыЧтения.СопоставлениеПоНаименованию;
	КонвертироватьДаты = ПараметрыЧтения.КонвертироватьДаты;
	
	ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресВХранилище);
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла(Расширение);
	ДвоичныеДанные.Записать(ИмяВременногоФайла);
	
	ТабДок = Новый ТабличныйДокумент;
	ТабДок.Прочитать(ИмяВременногоФайла, СпособЧтенияЗначенийТабличногоДокумента.Текст);
	
	Попытка
		// BSLLS:UsingSynchronousCalls-off
		УдалитьФайлы(ИмяВременногоФайла);
		// BSLLS:UsingSynchronousCalls-on
	Исключение
		ТекстОшибки = НСтр("ru = 'Загрузка файла через табличный документ.Удаление временного файла'");
		ЗаписьЖурналаРегистрации(ТекстОшибки,
			УровеньЖурналаРегистрации.Ошибка, , ,
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Лист = ?(ЗначениеЗаполнено(НазваниеЛиста), Табдок.Области.Найти(СтрЗаменить(НазваниеЛиста, " ", "_")), Неопределено);
	
	ПервыйЛист = ТабДок.Области[0].Имя;
	Для Каждого ЛистДок Из ТабДок.Области Цикл
		Если ЛистДок.Верх = 1 Тогда
			ПервыйЛист = ЛистДок.Имя;
		КонецЕсли;
	КонецЦикла;
	
	ТабДок = ТабДок.ПолучитьОбласть(?(Лист = Неопределено, ПервыйЛист, СтрЗаменить(НазваниеЛиста, " ", "_")));
	ТЗ = ПолучитьПромежуточнуюТаблицуЗначенийИзТабличногоДокумента(
		ТабДок, НомерСтроки, Макет, СопоставлениеПоНаименованию);
	
	КоллекцияОтборов = Новый ТаблицаЗначений;
	КоллекцияОтборов.Колонки.Добавить("ТипДанных");
	КоллекцияОтборов.Колонки.Добавить("НомерСтрокиДочерней");
	КоллекцияОтборов.Колонки.Добавить("МассивДанных");
	КоллекцияОтборов.Колонки.Добавить("НазваниеКолонки");
	
	Н = ТЗ.Количество() - 1;
	
	Пока Не Н < 0 Цикл
		
		Счетчик = 0;
		ТЗ[Н].ПорядковыйНомер = Н;
		
		Для Каждого Колонка Из ТЗ.Колонки Цикл
			Если Не ЗначениеЗаполнено(ТЗ[Н][Колонка.Имя]) Тогда
				Счетчик = Счетчик + 1;
			КонецЕсли;
		КонецЦикла;
		
		Если Счетчик = ТЗ.Колонки.Количество() Тогда
			ТЗ.Удалить(Н);
		КонецЕсли;
		
		Н = Н - 1;
		
	КонецЦикла;
	
	ВставкаВТ					= "";
	ВставкаБазовые				= "";
	ВставкаСсылочные			= "";
	ВставкаИсточники			= "";
	ХранилищеИсточников			= Новый Соответствие;
	МассивИменСсылочных			= Новый Массив;
	СтруктураИменКолонокДат		= Новый Структура;
	СоответствиеПеречислений	= Новый Соответствие;
	
	ДлинаЧисла = 15;
	ОписаниеТипаЧисло15 = Новый ОписаниеТипов("Число", , , Новый КвалификаторыЧисла(ДлинаЧисла));
	ШаблонИмяКолонки = "ВходнаяТаблица.%1 КАК %1," + Символы.ПС;
	СтрокаНеОбрабатывать = "НеОбрабатывать";
	СсылкаСтрока = "Ссылка";
	КодЧисломСтрока = "КодЧислом";
	ВходнаяТаблицаСтрока = "ВходнаяТаблица.";
	
	Для Каждого СтрокаТаблицы Из Макет Цикл
		
		Если Не ЗначениеЗаполнено(СтрокаТаблицы.ТипЗначения) Тогда
			Продолжить;
		КонецЕсли;
		
		ВставкаВТ = ВставкаВТ + СтрШаблон(ШаблонИмяКолонки, СтрокаТаблицы.ИмяКолонки);
		
		Если СтрНайти(СтрокаТаблицы.ТипЗначения, СсылкаСтрока) <> 0
			И СтрНайти(СтрокаТаблицы.ТипЗначения, "Перечисление") = 0 Тогда
			
			ТЗ.Колонки.Добавить(СтрокаТаблицы.ИмяКолонки + КодЧисломСтрока, ОписаниеТипаЧисло15);
			ВставкаВТ = ВставкаВТ + СтрШаблон(ШаблонИмяКолонки, СтрокаТаблицы.ИмяКолонки + КодЧисломСтрока);
			МассивИменСсылочных.Добавить(СтрокаТаблицы.ИмяКолонки);
			
			РазбивкаТипа = СтрРазделить(СтрЗаменить(СтрокаТаблицы.ТипЗначения, СсылкаСтрока, ""), ".", Ложь);
			ИмяОбъекта = РазбивкаТипа[1];
			
			ВхождениеИсточника = ХранилищеИсточников.Получить(ИмяОбъекта);
			ХранилищеИсточников.Вставить(ИмяОбъекта, ?(ВхождениеИсточника = Неопределено, 1, ВхождениеИсточника + 1));
			Итерация = ?(ХранилищеИсточников.Получить(ИмяОбъекта) = 0, "", Строка(ХранилищеИсточников.Получить(ИмяОбъекта)));
			
			// В макете могут быть заявлены поля, для которых не назначили полей поиска
			ЕстьПоляПоиска = ЗначениеЗаполнено(СтрокаТаблицы.ПолеПоиска1)
				Или ЗначениеЗаполнено(СтрокаТаблицы.ПолеПоиска2)
				Или ЗначениеЗаполнено(СтрокаТаблицы.ПолеПоиска3);
			Если ЕстьПоляПоиска Тогда
				ВставкаСсылочные = ВставкаСсылочные + ИмяОбъекта + Итерация
					+ ".Ссылка КАК " + СтрокаТаблицы.ИмяКолонки + "," + Символы.ПС;
			Иначе
				ВставкаСсылочные = ВставкаСсылочные + "НЕОПРЕДЕЛЕНО КАК "
					 + СтрокаТаблицы.ИмяКолонки + "," + Символы.ПС;
			КонецЕсли;
			
			ОператорСравнения = ?(ПустаяСтрока(СтрокаТаблицы.ОператорСравнения),
				"ИЛИ", СтрокаТаблицы.ОператорСравнения);
			
			Если Не СтрНайти(ВставкаИсточники, " " + ИмяОбъекта + " ") > 0 И ЕстьПоляПоиска Тогда
				ВставкаУсловияСоединения = "";
				Для Инкремент = 1 По 3 Цикл
					РеквизитСравнения = СтрокаТаблицы["ПолеПоиска" + Инкремент];
					Если ПустаяСтрока(РеквизитСравнения) Тогда
						Продолжить;
					КонецЕсли;
					
					// Возможно использование оператора И для сопоставления, но при его использовании
					// имена полей поиска должны равняться именам колонок обрабатываемой таблицы. Например:
					// Если в свойствах макета у колонки заполнен тип ДокументСсылка., ПолеПоиска1 = "Номер",
					// а ПолеПоиска2 = "Дата" И ОператорСравнения = "И", тогда таблица построителя должна иметь
					// колонки "Номер", где лежит номер документа и "Дата", где лежит дата документа.
					Если ОператорСравнения = "ИЛИ" Тогда
						ИмяКолонкиСравнения = СтрокаТаблицы.ИмяКолонки;
					Иначе
						ИмяКолонкиСравнения = РеквизитСравнения;
					КонецЕсли;
					
					ВставкаУсловияСоединения = ВставкаУсловияСоединения
						+ ?(ПустаяСтрока(ВставкаУсловияСоединения), "", Символы.ПС + "
						|		" + ОператорСравнения + " ") + ВходнаяТаблицаСтрока + ИмяКолонкиСравнения
						+ " = " + ИмяОбъекта + Итерация + "." + РеквизитСравнения;
				КонецЦикла;
				
				Если Не ПустаяСтрока(ВставкаУсловияСоединения) Тогда
					ВставкаИсточники = ВставкаИсточники + "
					|		ЛЕВОЕ СОЕДИНЕНИЕ " + СтрЗаменить(СтрокаТаблицы.ТипЗначения, СсылкаСтрока, "")
					+ " КАК " + ИмяОбъекта + Итерация + "
					|		ПО ВходнаяТаблица." + СтрокаТаблицы.ИмяКолонки + " <> """" И "
					+ ВходнаяТаблицаСтрока + СтрокаТаблицы.ИмяКолонки + " <> 0
					|		И (" + ВставкаУсловияСоединения + ")";
				КонецЕсли;
				
				ВставкаБазовые = ВставкаБазовые + ВходнаяТаблицаСтрока + СтрокаТаблицы.ИмяКолонки
					+ " КАК " + СтрокаТаблицы.ИмяКолонки + "Служебный," + Символы.ПС;
			КонецЕсли;
			
		ИначеЕсли СтрНайти(СтрокаТаблицы.ТипЗначения, "Перечисление") <> 0 Тогда
			КолонкаПеречисления = ТЗ.Колонки.Добавить(СтрокаТаблицы.ИмяКолонки + СтрокаНеОбрабатывать,
				Новый ОписаниеТипов(СтрокаТаблицы.ТипЗначения));
			СоответствиеПеречислений.Вставить(СтрокаТаблицы.ИмяКолонки, СтрокаТаблицы.ТипЗначения);
			ВставкаВТ = СтрЗаменить(ВставкаВТ, "." + СтрокаТаблицы.ИмяКолонки + " КАК", "." + КолонкаПеречисления.Имя + " КАК");
			ВставкаБазовые = ВставкаБазовые + СтрШаблон(ШаблонИмяКолонки, СтрокаТаблицы.ИмяКолонки);
		ИначеЕсли Не СтрНайти(СтрокаТаблицы.ИмяКолонки, СтрокаНеОбрабатывать) > 0 Тогда
			ВставкаБазовые = ВставкаБазовые + СтрШаблон(ШаблонИмяКолонки, СтрокаТаблицы.ИмяКолонки);
			Если СтрНайти(СтрокаТаблицы.ТипЗначения, "Дата") <> 0
				И ТЗ.Колонки.Найти(СтрокаТаблицы.ИмяКолонки + "Строкой") <> Неопределено Тогда
				СтруктураИменКолонокДат.Вставить(СтрокаТаблицы.ИмяКолонки, "");
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	ВставкаВТ		= ВставкаВТ + "ВходнаяТаблица.ПорядковыйНомер Как ПорядковыйНомер";
	КоличествоСимволовЛев = 2;
	ВставкаБазовые	= Лев(ВставкаБазовые, СтрДлина(ВставкаБазовые) - КоличествоСимволовЛев);
	
	Если КонвертироватьДаты Тогда
		ПрисвоитьНомераФорматовКолонокДат(ТЗ, СтруктураИменКолонокДат);
	КонецЕсли;
	
	Для Каждого СтрокаТаблицы Из ТЗ Цикл
		
		Для Каждого ИмяМассива Из МассивИменСсылочных Цикл
			СтрокаТаблицы[ИмяМассива + КодЧисломСтрока] = ОписаниеТипаЧисло15.ПривестиЗначение(СтрокаТаблицы[ИмяМассива]);
		КонецЦикла;
		
		Для Каждого Колонка Из СоответствиеПеречислений Цикл
			ИмяПеречисления = СтрЗаменить(Колонка.Значение, "ПеречислениеСсылка.", "");
			
			Для Каждого ТекЭлемент Из Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления Цикл
				Если НРег(ТекЭлемент.Синоним) = НРег(СтрокаТаблицы[Колонка.Ключ]) Тогда
					СтрокаТаблицы[Колонка.Ключ + СтрокаНеОбрабатывать] = Перечисления[ИмяПеречисления][ТекЭлемент.Имя];
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
		КонецЦикла;
		
		Если КонвертироватьДаты Тогда
			Для Каждого КлючИЗначение Из СтруктураИменКолонокДат Цикл
				СтрокаТаблицы[КлючИЗначение.Ключ] = ПреобразоватьДатуИзСтрокиПоФормату(
					СтрокаТаблицы[КлючИЗначение.Ключ + "Строкой"], КлючИЗначение.Значение);
			КонецЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	#ВставкаВТ
	|ПОМЕСТИТЬ ВходнаяТаблица
	|ИЗ
	|	&ВходнаяТаблица КАК ВходнаяТаблица
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	#ВставкаСсылочные
	|	#ВставкаБазовые
	|ИЗ
	|	ВходнаяТаблица КАК ВходнаяТаблица
	|		#ВставкаИсточники
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВходнаяТаблица.ПорядковыйНомер";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "#ВставкаВТ", ВставкаВТ);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "#ВставкаСсылочные", ВставкаСсылочные);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "#ВставкаБазовые", ВставкаБазовые);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "#ВставкаИсточники", ВставкаИсточники);
	
	Запрос.УстановитьПараметр("ВходнаяТаблица", ТЗ);
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыгрузкаРезультатаЗапроса = РезультатЗапроса.Выгрузить();
	
	Возврат ВыгрузкаРезультатаЗапроса;
	
КонецФункции

// Возвращает таблицу значений без null в ячейках
//
// Параметры:
//  ТаблицаЗначений	 - ТаблицаЗначений - таблица, в которой необходимо подменить значения
//  фИзменилиТаблицу - Булево - флаг, оповещающий о том, что в таблице были выполнены замены
//
Процедура ТаблицаЗначенийБезNull(ТаблицаЗначений, фИзменилиТаблицу = Ложь) Экспорт
	
	фИзменилиТаблицу = Ложь;
	
	чКрайний = ТаблицаЗначений.Колонки.Количество() - 1;
	Для чИндекс = 0 По чКрайний Цикл
		
		ТипКолонки = ТаблицаЗначений.Колонки[чИндекс].ТипЗначения;
		
		Если ТипКолонки.СодержитТип(Тип("Null")) Тогда
			
			ИмяКолонки			= ТаблицаЗначений.Колонки[чИндекс].Имя;
			ЗаголовокКолонки	= ТаблицаЗначений.Колонки[чИндекс].Заголовок;
			ШиринаКолонки		= ТаблицаЗначений.Колонки[чИндекс].Ширина;
			ЗначениеКолонки		= ТаблицаЗначений.ВыгрузитьКолонку(чИндекс);
			ТипКолонки = Новый ОписаниеТипов(ТипКолонки, ,"NULL",
				ТипКолонки.КвалификаторыЧисла,
				ТипКолонки.КвалификаторыСтроки,
				ТипКолонки.КвалификаторыДаты,
				ТипКолонки.КвалификаторыДвоичныхДанных);
			
			ТаблицаЗначений.Колонки.Удалить(чИндекс);
			ТаблицаЗначений.Колонки.Вставить(чИндекс, ИмяКолонки, ТипКолонки, ЗаголовокКолонки, ШиринаКолонки);
			ТаблицаЗначений.ЗагрузитьКолонку(ЗначениеКолонки, чИндекс);
			
			фИзменилиТаблицу = Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти // ПрограммныйИнтерфейс

#Область СлужебныеПроцедурыИФункции

Функция ПолучитьПромежуточнуюТаблицуЗначенийИзТабличногоДокумента(
	ТабДок, НомерСтроки, Макет, СопоставлениеПоНаименованию)
	
	Если Не НомерСтроки = 1 Тогда
		ТабДок.УдалитьОбласть(ТабДок.Область("R1:R" + Строка(НомерСтроки - 1)), ТипСмещенияТабличногоДокумента.ПоВертикали);
	КонецЕсли;
	
	Если Не СопоставлениеПоНаименованию Тогда
		ПреобразоватьТабличныйДокументПоследовательнымСопоставлением(ТабДок, Макет);
	Иначе
		ПреобразоватьТабличныйДокументСопоставлениемПоНаименованиюКолонок(ТабДок, Макет);
	КонецЕсли;
	
	ПЗ							= Новый ПостроительЗапроса;
	ПЗ.ИсточникДанных			= Новый ОписаниеИсточникаДанных(ТабДок.Область());
	ПЗ.ДобавлениеПредставлений	= ТипДобавленияПредставлений.Добавлять;
	ПЗ.ЗаполнитьНастройки();
	ПЗ.Выполнить();
	ТЗ = ПЗ.Результат.Выгрузить();
	
	Если СопоставлениеПоНаименованию Тогда
		// Дополняем колонками из макета, если в ТД они отсутствовали
		Для Каждого СтрокаМакета Из Макет Цикл
			Если ТЗ.Колонки.Найти(СтрокаМакета.ИмяКолонки) = Неопределено Тогда
				ТЗ.Колонки.Добавить(СтрокаМакета.ИмяКолонки, Новый ОписаниеТипов(СтрокаМакета.ТипЗначения));
			Иначе
				// Для колонок с типом Дата необходимо преобразование
				Если СтрокаМакета.ТипЗначения = "Дата" Тогда
					ТЗ.Колонки[СтрокаМакета.ИмяКолонки].Имя = ТЗ.Колонки[СтрокаМакета.ИмяКолонки].Имя + "Строкой";
					ТЗ.Колонки.Добавить(СтрокаМакета.ИмяКолонки, Новый ОписаниеТипов("Дата"));
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Удаляем пустые строки, которые остались от объединения строк
	ИмяКолонки1 = ТЗ.Колонки[0].Имя;
	ИмяКолонки2 = ТЗ.Колонки[1].Имя;
	ИмяКолонки3 = ТЗ.Колонки[2].Имя;
	КоличествоСтрок = ТЗ.Количество() - 1;
	Пока КоличествоСтрок >= 0 Цикл
		СтрокаТаблицы = ТЗ[КоличествоСтрок];
		Если ПустаяСтрока(СтрокаТаблицы[ИмяКолонки1])
			И ПустаяСтрока(СтрокаТаблицы[ИмяКолонки2])
			И ПустаяСтрока(СтрокаТаблицы[ИмяКолонки3]) Тогда
			ТЗ.Удалить(СтрокаТаблицы);
		КонецЕсли;
		
		КоличествоСтрок = КоличествоСтрок - 1;
	КонецЦикла;
	
	ТЗ.Колонки.Добавить("ПорядковыйНомер", Новый ОписаниеТипов("Число"));
	
	Возврат ТЗ;
	
КонецФункции

Процедура ПреобразоватьТабличныйДокументПоследовательнымСопоставлением(ТабДок, Макет)
	
	ТабДок.ВставитьОбласть(ТабДок.Область("R1"),
		ТабДок.Область("R1"),
		ТипСмещенияТабличногоДокумента.ПоГоризонтали);
	
	Табдок.Область("R1").Очистить(Истина, Истина, Истина);
	
	Счетчик = 0;
	Для Каждого СтрокаТаблицы Из Макет Цикл
		Счетчик = Счетчик + 1;
		Если Не ЗначениеЗаполнено(СтрокаТаблицы.ТипЗначения) Тогда
			Продолжить;
		КонецЕсли;
		ТабДок.Область("R1" + "C" + Строка(Счетчик)).Текст = СтрокаТаблицы.ИмяКолонки;
	КонецЦикла;
	
КонецПроцедуры

Процедура ПреобразоватьТабличныйДокументСопоставлениемПоНаименованиюКолонок(ТабДок, Макет)
	
	Счетчик = 1;
	КолонкиКУдалению = Новый Массив;
	ТекстШапки = СокрЛП(ТабДок.Область("R1" + "C" + Строка(Счетчик)).Текст);
	Пока Не ПустаяСтрока(ТекстШапки) Цикл
		ИмяКолонки = "";
		// Сверяем наименование колонки ТД и наименование из макета
		Для Каждого СтрокаТаблицы Из Макет Цикл
			Если Не ЗначениеЗаполнено(СтрокаТаблицы.ТипЗначения) Тогда
				Продолжить;
			КонецЕсли;
			Если ПроверитьСоответствиеИменКолонок(ТекстШапки, СтрокаТаблицы.ИмяВТабДоке, СтрокаТаблицы.ИмяКолонки) Тогда
				ИмяКолонки = СтрокаТаблицы.ИмяКолонки;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		// Подменяем имя для работы с построителем; если колонки нет, то готовим ее к удалению
		Если Не ПустаяСтрока(ИмяКолонки) Тогда
			ТабДок.Область("R1" + "C" + Строка(Счетчик)).Текст = ИмяКолонки;
		Иначе
			КолонкиКУдалению.Добавить(Счетчик);
		КонецЕсли;
		
		Счетчик = Счетчик + 1;
		ТекстШапки = СокрЛП(ТабДок.Область("R1" + "C" + Строка(Счетчик)).Текст);
	КонецЦикла;
	
	// Удаляем ненужные колонки
	КоличествоКолонокКУдалению = КолонкиКУдалению.Количество() - 1;
	Пока КоличествоКолонокКУдалению >= 0 Цикл
		НомерКолонки = КолонкиКУдалению[КоличествоКолонокКУдалению];
		ТабДок.УдалитьОбласть(ТабДок.Область("C" + Строка(НомерКолонки)), ТипСмещенияТабличногоДокумента.ПоГоризонтали);
		
		КоличествоКолонокКУдалению = КоличествоКолонокКУдалению - 1;
	КонецЦикла;
	
КонецПроцедуры

Функция ПроверитьСоответствиеИменКолонок(ТекстШапки, ИмяВТабДоке, ИмяКолонки)
	
	Возврат (ЗначениеЗаполнено(ИмяВТабДоке) И ТекстШапки = ИмяВТабДоке)
		Или (Не ЗначениеЗаполнено(ИмяВТабДоке) И ТекстШапки = ИмяКолонки);
	
КонецФункции

Процедура ПрисвоитьНомераФорматовКолонокДат(ТЗ, СтруктураИменКолонокДат)
	
	Если Не ТЗ.Количество() Тогда
		Возврат;
	КонецЕсли;
	
	ПерваяСтрокаТаблицы = ТЗ[0];
	
	Для Каждого КлючИЗначение Из СтруктураИменКолонокДат Цикл
		ЗначениеКолонки = ПерваяСтрокаТаблицы[КлючИЗначение.Ключ + "Строкой"];
		Если ПустаяСтрока(ЗначениеКолонки) Тогда
			Продолжить;
		КонецЕсли;
		
		СтруктураИменКолонокДат.Вставить(КлючИЗначение.Ключ, ПолучитьНомерФорматаДатыИзСтроки(ЗначениеКолонки));
	КонецЦикла;
	
КонецПроцедуры

// Получает номер формата даты из строки
//
// Параметры:
//  ЗначениеКолонки	 - Строка - дата строкой
// 
// Возвращаемое значение:
//  Строка - номер формата с разделителями "_". Первый разряд показывает какой разделитель используется
//  в представлении даты, второй разряд показывает положение дня, месяца и года по отношению друг к другу, третий разряд
//  показывает представление времени в дате. Если номер формата "000" - преобразование происходит из функции XMLЗначение.
//  Первый разряд принимает значения:
//   - 1 - разделитель ".";
//   - 2 - "/";
//   - 3 - "-";
//   - 4 - " ";
//  Второй разряд принимает значения:
//   - 1 - год идет первым, потом месяц и день;
//   - 2 - сначала день, потом месяц и год;
//   - 3 - сначала день, месяц СТРОКОЙ и год;
//  Третий разряд принимает значения:
//   - 0 - время отсутствует;
//   - 1 - время стандартное, 24-часовое представление
//   - 2 - время в 12-ти часовом представлении (AM / PM)
// 
//  Примеры номеров форматов:
//   - 1_1_2 - "2021.12.01 8:10 PM";
//   - 2_1_0 - "2021/12/01";
//   - 1_3_1 - "01.дек.2021 20:10";
//   - 3_1_1 - "2021-12-01 20:10"
//
Функция ПолучитьНомерФорматаДатыИзСтроки(ЗначениеКолонки)
	
	ЕстьВремя = СтрНайти(ЗначениеКолонки, ":") > 0;
	ЭтоУниверсальноеВремя = Ложь;
	
	Если ЕстьВремя Тогда
		МассивРазделителей = пбп_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
			ЗначениеКолонки, ":", Истина, Истина);
		Если СтрНайти(МассивРазделителей[1], "AM") > 0
			Или СтрНайти(МассивРазделителей[1], "PM") > 0 Тогда
			РазрядВремени = "2";
		Иначе
			РазрядВремени = "1";
		КонецЕсли;
		
		МассивРазделителейДатаВремя = пбп_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
			МассивРазделителей[0], " ", Истина, Истина);
		КоличествоРазделителей = 2;
		Если МассивРазделителейДатаВремя.Количество() = КоличествоРазделителей Тогда
			ТолькоДата = МассивРазделителейДатаВремя[0];
		ИначеЕсли МассивРазделителейДатаВремя.Количество() = 0 Тогда
			МассивРазделителейДатаВремя = пбп_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
				МассивРазделителей[0], "T", Истина, Истина);
			Если МассивРазделителейДатаВремя.Количество() = КоличествоРазделителей Тогда
				ТолькоДата = МассивРазделителейДатаВремя[0];
				ЭтоУниверсальноеВремя = Истина;
			КонецЕсли;
		Иначе
			ТолькоДата = ПолучитьТолькоДатуЕслиРазделительПробел(МассивРазделителейДатаВремя);
		КонецЕсли;
	Иначе
		ТолькоДата = ЗначениеКолонки;
		РазрядВремени = "0";
	КонецЕсли;
	
	Если Не ЭтоУниверсальноеВремя Тогда
		Если СтрНайти(ТолькоДата, ".") > 0 Тогда
			РазрядРазделителя = "1";
			РазрядФормата = ПолучитьРазрядФорматаДатыИзСтроки(ЗначениеКолонки, ".");
		ИначеЕсли СтрНайти(ТолькоДата, "/") > 0 Тогда
			РазрядРазделителя = "2";
			РазрядФормата = ПолучитьРазрядФорматаДатыИзСтроки(ЗначениеКолонки, "/");
		ИначеЕсли СтрНайти(ТолькоДата, "-") > 0 Тогда
			РазрядРазделителя = "3";
			РазрядФормата = ПолучитьРазрядФорматаДатыИзСтроки(ЗначениеКолонки, "-");
		Иначе
			РазрядРазделителя = "4";
			РазрядФормата = ПолучитьРазрядФорматаДатыИзСтроки(ЗначениеКолонки, " ");
		КонецЕсли;
	Иначе
		РазрядРазделителя = "0";
		РазрядФормата = "0";
		РазрядВремени = "0";
	КонецЕсли;
	
	Возврат РазрядРазделителя + "_" + РазрядФормата + "_" + РазрядВремени;
	
КонецФункции

Функция ПолучитьРазрядФорматаДатыИзСтроки(ЗначениеКолонки, Разделитель)
	
	МассивРазделителей = пбп_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
		ЗначениеКолонки, Разделитель, Истина, Истина);
	КоличествоПервыхСимволов = 3;
	МаксКоличествоДнейВМесяце = 31;
	СокрМесяц = ТРег(Лев(МассивРазделителей[1], КоличествоПервыхСимволов));
	Если Число(МассивРазделителей[0]) > МаксКоличествоДнейВМесяце Тогда // тут год
		РазрядФормата = "1";
	ИначеЕсли пбп_ОбщегоНазначенияКлиентСервер.ПолучитьНомерМесяцаПоСтроковомуПредставлению(СокрМесяц) = 0 Тогда
		РазрядФормата = "2";
	Иначе
		РазрядФормата = "3";
	КонецЕсли;
	
	Возврат РазрядФормата;
	
КонецФункции

Функция ПолучитьТолькоДатуЕслиРазделительПробел(МассивРазделителейДатаВремя)
	
	КоличествоСмещений = 2;
	КоличествоРазделителей = МассивРазделителейДатаВремя.Количество() - КоличествоСмещений; // В последнем часы
	Для Разделитель = 0 По КоличествоРазделителей Цикл
		ТолькоДата = ТолькоДата + ?(ПустаяСтрока(ТолькоДата), "", " ") + МассивРазделителейДатаВремя[Разделитель];
	КонецЦикла;
	
	Возврат ТолькоДата;
	
КонецФункции

// Преобразовать дату из строки по строковому формату
//
// Параметры:
//  ВхЗначение	 - Строка - дата строкой
//  НомерФормата - Строка - номер формата с разделителями "_". Подробнее см. в ПолучитьНомерФорматаДатыИзСтроки
// 
// Возвращаемое значение:
//  Дата - дата, полученная из преобразования даты строкой по формату
//
Функция ПреобразоватьДатуИзСтрокиПоФормату(ВхЗначение, НомерФормата)
	
	ПреобразованнаяДата = Неопределено;
	Если НомерФормата = "000" Тогда
		ПреобразованнаяДата = XMLЗначение(Тип("Дата"), ВхЗначение);
	Иначе
		РазрядыФормата = пбп_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(НомерФормата, "_");
		
		СтрокаВремя = "";
		Если РазрядыФормата[2] = "0" Тогда
			СтрокаВремя = "00:00:00";
			ТолькоДата = ВхЗначение;
		Иначе
			МассивРазделителей = пбп_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
				ВхЗначение, ":", Истина, Истина);
			
			МассивРазделителейДатаВремя = пбп_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
				МассивРазделителей[0], " ", Истина, Истина);
			Если РазрядыФормата[0] = "4" Тогда
				ТолькоДата = ПолучитьТолькоДатуЕслиРазделительПробел(МассивРазделителейДатаВремя);
			Иначе
				ТолькоДата = МассивРазделителейДатаВремя[0];
			КонецЕсли;
			
			Если РазрядыФормата[1] = "1" Тогда
				Часы = МассивРазделителейДатаВремя[МассивРазделителейДатаВремя.Количество() - 1];
				МинутыСекунды = МассивРазделителей[1];
			Иначе
				ЧасыБезСдвигаЧисло = Число(МассивРазделителейДатаВремя[МассивРазделителейДатаВремя.Количество() - 1]);
				КоличествоСимволовДоПослеОбеда = 2;
				КоличествоЧасовСдвига = 12;
				Если Прав(МинутыСекунды, КоличествоСимволовДоПослеОбеда) = "PM" Тогда
					Часы = ЧасыБезСдвигаЧисло + КоличествоЧасовСдвига;
				Иначе
					Часы = ЧасыБезСдвигаЧисло;
				КонецЕсли;
				
				МинутыСекунды = СтрЗаменить(МинутыСекунды, " AM", "");
				МинутыСекунды = СтрЗаменить(МинутыСекунды, " PM", "");
			КонецЕсли;
			
			СтрокаВремя = Строка(Часы) + ":" + МинутыСекунды;
		КонецЕсли;
		
		Если РазрядыФормата[0] = "1" Тогда
			РазделительРазрядов = ".";
		ИначеЕсли РазрядыФормата[0] = "2" Тогда
			РазделительРазрядов = "/";
		ИначеЕсли РазрядыФормата[0] = "3" Тогда
			РазделительРазрядов = "-";
		Иначе
			РазделительРазрядов = " ";
		КонецЕсли;
		
		МассивГодМесяцДата = пбп_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
			ТолькоДата, РазделительРазрядов, Истина, Истина);
		
		Если РазрядыФормата[1] = "1" Тогда
			Год = МассивГодМесяцДата[0];
			Месяц = МассивГодМесяцДата[1];
			День = МассивГодМесяцДата[2];
		ИначеЕсли РазрядыФормата[1] = "2" Тогда
			Год = МассивГодМесяцДата[2];
			Месяц = МассивГодМесяцДата[1];
			День = МассивГодМесяцДата[0];
		Иначе
			Год = МассивГодМесяцДата[2];
			КоличествоПервыхСимволов = 3;
			СокрМесяц = ТРег(Лев(МассивГодМесяцДата[1], КоличествоПервыхСимволов));
			Месяц = пбп_ОбщегоНазначенияКлиентСервер.ПолучитьНомерМесяцаПоСтроковомуПредставлению(СокрМесяц);
			День = МассивГодМесяцДата[0];
		КонецЕсли;
		
		НомерЧислаБезНуля = 10;
		Если Число(Месяц) < НомерЧислаБезНуля И Лев(Месяц, 1) <> "0" Тогда
			Месяц = "0" + Месяц;
		КонецЕсли;
		
		Если Число(День) < НомерЧислаБезНуля И Лев(День, 1) <> "0" Тогда
			День = "0" + День;
		КонецЕсли;
		
		СтрокаДата = День + "." + Месяц + "." + Год;
		
		ПреобразованнаяДата = Дата(СтрокаДата + " " + СтрокаВремя);
		
	КонецЕсли;
	
	Возврат ПреобразованнаяДата;
	
КонецФункции

#КонецОбласти // СлужебныеПроцедурыИФункции