// Библиотека проектных подсистем для упрощения разработки архитектуры на 1С: Предприятие 8,
// включая доработку типовых конфигураций.
//
// Copyright First BIT company
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
// URL:    https://github.com/firstBitSportivnaya/PSSL/
//

////////////////////////////////////////////////////////////////////////////////
// Общего назначения (сервер): для серверных функций общего назначения

#Область ПрограммныйИнтерфейс

// Возвращает имя информационной базы.
// 
// Возвращаемое значение:
//   - Строка - Имя информационной базы.
//
Функция ПолучитьИмяИнформационнойБазы() Экспорт
	
	СтрокаПодключения = СтрокаСоединенияИнформационнойБазы();
	
	НомерСимвола = СтрНайти(СтрокаПодключения, "File=");
	Если НомерСимвола > 0 Тогда
		
		// Это Файловая база.
		СтрокаСправа = Сред(СтрокаПодключения, НомерСимвола + 6);
		
		Возврат Сред(СтрокаСправа, 1, СтрДлина(СтрокаСправа) - 2);
	КонецЕсли;
	
	НомерСимвола = СтрНайти(СтрокаПодключения, "Ref=");
	Если НомерСимвола > 0 Тогда
		
		// Это серверная база.
		СтрокаСправа = Сред(СтрокаПодключения, НомерСимвола + 5);
		
		Возврат Сред(СтрокаСправа, 1, СтрДлина(СтрокаСправа) - 2);
	КонецЕсли;
	
	Возврат "";
	
Конецфункции

// Возвращает значение предопределенного элемента ПВХ по имени.
//
// Параметры:
//  Имя - Строка - Имя переменной ПВХ.
//  ИспользоватьКэш - Булево - Признак получения данных из кэша.
// 
// Возвращаемое значение:
//  - ПроизвольныйТип - Значение переменной ПВХ.
//  - Массив - Массив значений переменной ПВХ.
// 
Функция ПолучитьПредопределенноеЗначение(Имя, ИспользоватьКэш = Ложь) Экспорт
	
	Если ИспользоватьКэш Тогда
		Возврат __ОбщегоНазначенияПовтИсп.ПолучитьПредопределенноеЗначение(Имя);
	Иначе
		Возврат ПланыВидовХарактеристик.__ПредопределенныеЗначения.ПолучитьЗначение(Имя);
	КонецЕсли;
	
КонецФункции

// Возвращает соответствие предопределенных элементов ПВХ по имени.
//
// Параметры:
//  Имя - Строка - Имена переменных ПВХ, перечисленные через запятую.
//  ВРазрезеКлючей - Булево - Признак получения данных в виде соответствия, где Ключ - Имя переменной.
//  ИспользоватьКэш - Булево - Признак получения данных из кэша.
// 
// Возвращаемое значение:
//  - Соответствие - Соответствие имен и значений переменных ПВХ.
//  - Массив - Массив значений переменных ПВХ.
//
Функция ПолучитьПредопределенныеЗначения(Имена, ВРазрезеКлючей = Ложь, ИспользоватьКэш = Ложь) Экспорт
	
	Если ИспользоватьКэш Тогда
		Возврат __ОбщегоНазначенияПовтИсп.ПолучитьПредопределенныеЗначения(Имена, ВРазрезеКлючей);
	Иначе
		Возврат ПланыВидовХарактеристик.__ПредопределенныеЗначения.ПолучитьЗначения(Имена, ВРазрезеКлючей);
	КонецЕсли;
	
КонецФункции

// Возвращает массив структур соответствий по отбору
//
// Параметры:
//  ТипСоответствия - СправочникСсылка.__ТипСоответствияОбъектовИБ - Тип соответствия.
//  Объект1 - ПроизвольныйТип - Объект1.
//  Объект2 - ПроизвольныйТип - Объект2.
//  Объект3 - ПроизвольныйТип - Объект3.
//  ИспользоватьКэш - Булево - Признак получения данных из кэша.
// 
// Возвращаемое значение:
//  - Массив - соответствие объектов ИБ в виде структур.
//
Функция ПолучитьСоответствиеОбъектовИБ(ТипСоответствия, Объект1 = Неопределено, Объект2 = Неопределено, Объект3 = Неопределено, ИспользоватьКэш = Ложь) Экспорт
	
	Если ИспользоватьКэш Тогда
		Возврат __ОбщегоНазначенияПовтИсп.ПолучитьСоответствиеОбъектовИБ(ТипСоответствия, Объект1, Объект2, Объект3);
	Иначе
		Возврат РегистрыСведений.__СоответствияОбъектовИБ.ПолучитьСоответствиеОбъектовИБ(ТипСоответствия, Объект1, Объект2, Объект3);
	КонецЕсли;
	
КонецФункции

// Возвращает таблицу значений с датами за период
//
// Параметры:
//  НачалоПериода	 - Дата - Начало периода.
//  ОкончаниеПериода - Дата - Конец периода.
//  Интервал		 - Строка - одно из следующих значений:
//             (Секунда, Минута, Час, День, Неделя, Месяц, Квартал, Полугодие, Год)
// 
// Возвращаемое значение:
//  ТаблицаЗначений - Таблица значений с датами за период. Содержит одну колонку "Период".
//
Функция ПолучитьТаблицуДатЗаПериод(НачалоПериода, ОкончаниеПериода, Интервал = "День") Экспорт
	
	ТаблицаИнтервалов = Новый ТаблицаЗначений;
	ТаблицаИнтервалов.Колонки.Добавить("Период", Новый ОписаниеТипов("Дата"));
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
		|	НАЧАЛОПЕРИОДА(&НачалоПериода, ДЕНЬ) КАК Период
		|
		|УПОРЯДОЧИТЬ ПО
		|	Период
		|ИТОГИ ПО
		|	Период ПЕРИОДАМИ(%Интервал%, &НачалоПериода, &ОкончаниеПериода)";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "%Интервал%", Интервал);
	
	Запрос.УстановитьПараметр("НачалоПериода", НачалоПериода);
	Запрос.УстановитьПараметр("ОкончаниеПериода", ОкончаниеПериода);
	
	Выборка = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, "Период", "ВСЕ");
	Пока Выборка.Следующий() Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаИнтервалов.Добавить(), Выборка);
	КонецЦикла;
	
	Возврат ТаблицаИнтервалов;
	
КонецФункции

//Устанавливает элемент отбор динамического списка
//
//Параметры:
//Список			- обрабатываемый динамический список,
//ИмяПоля			- имя поля компоновки, отбор по которому нужно установить,
//ВидСравнения		- вид сравнения отбора, по умолчанию - Равно,
//ПравоеЗначение 	- значение отбора
//
Процедура УстановитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение, ВидСравнения = Неопределено, Представление = "") Экспорт
	
	ЭлементОтбора = Список.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбора.ЛевоеЗначение		= Новый ПолеКомпоновкиДанных(ИмяПоля);
	ЭлементОтбора.ВидСравнения		= ?(ВидСравнения = Неопределено, ВидСравненияКомпоновкиДанных.Равно, ВидСравнения);
	ЭлементОтбора.Использование		= Истина;
	ЭлементОтбора.ПравоеЗначение	= ПравоеЗначение;
	ЭлементОтбора.Представление		= Представление;
	
КонецПроцедуры

//Изменяет элемент отбора динамического списка
//
//Параметры:
//Список         - обрабатываемый динамический список,
//ИмяПоля        - имя поля компоновки, отбор по которому нужно установить,
//ВидСравнения   - вид сравнения отбора, по умолчанию - Равно,
//ПравоеЗначение - значение отбора,
//Установить     - признак необходимости установить отбор
//
Процедура ИзменитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение = Неопределено, Установить = Ложь, ВидСравнения = Неопределено) Экспорт
	
	УдалитьЭлементОтбораСписка(Список, ИмяПоля);
	
	Если Установить Тогда
		
		УстановитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение, ВидСравнения);
		
	КонецЕсли;
	
КонецПроцедуры

//Удаляет элемент отбора динамического списка
//
//Параметры:
//Список  - обрабатываемый динамический список,
//ИмяПоля - имя поля компоновки, отбор по которому нужно удалить
//
Процедура УдалитьЭлементОтбораСписка(Список, ИмяПоля) Экспорт
	
	ЭлементыДляУдаления = Новый Массив;
	
	ЭлементыОтбора = Список.Отбор.Элементы;
	ПолеКомпоновки = Новый ПолеКомпоновкиДанных(ИмяПоля);
	
	Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл
		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных")
			И ЭлементОтбора.ЛевоеЗначение = ПолеКомпоновки Тогда
			ЭлементыДляУдаления.Добавить(ЭлементОтбора);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ЭлементОтбораДляУдаления Из ЭлементыДляУдаления Цикл
		
		ЭлементыОтбора.Удалить(ЭлементОтбораДляУдаления);
		
	КонецЦикла;
	
КонецПроцедуры

// Функция возвращает полный текст ошибки возникающей при исключении
//
// Параметры:
//	ЗаголовокОшибки - Строка - описание действия повлекшего ошибку
//	ТекстИсключения - Строка - подробное представление ошибки
//	ДополнительныеСообщения - Массив - массив дополнительных сообщений
Функция ПолучениеПолногоТекстаОшибкиПриИсключении(ЗаголовокОшибки, ТекстИсключения, ДополнительныеСообщения) Экспорт

	ТекстОшибки = ЗаголовокОшибки;
	Для Каждого Сообщение Из ДополнительныеСообщения Цикл
		ТекстОшибки = ТекстОшибки + Символы.ПС + Сообщение.Текст;
	КонецЦикла;
	ТекстОшибки = ТекстОшибки + Символы.ПС + ТекстИсключения;
	
	Возврат ТекстОшибки;

КонецФункции

// Процедура удаляет экземпляр регламентного задания.
// 
// Параметры:
//  КлючЗадания - Строка - Ключ регламентного задания
//
Процедура УдалитьЭкземплярРегламентногоЗадания(КлючЗадания) Экспорт
	
	ОтборЗадания = Новый Структура;
	ОтборЗадания.Вставить("Ключ", КлючЗадания);
	МассивРегламентныхЗаданий = __РегламентныеЗаданияСлужебныйСервер.НайтиЗадания(ОтборЗадания);
	
	Если МассивРегламентныхЗаданий.Количество() Тогда
		РегламентноеЗадание = МассивРегламентныхЗаданий[0];
		__РегламентныеЗаданияСлужебныйСервер.УдалитьЗадание(РегламентноеЗадание.УникальныйИдентификатор);
	КонецЕсли;
	
КонецПроцедуры

// Выполняет запись элемента справочника.
// 
// Параметры:
//  ТекущийОбъект  - СправочникОбъект - Записываемый объект.
//  Заголовок      - Строка (По умолчанию = "").
//  РежимСообщений - Строка: "Нет","Все","Ошибки" (По умолчанию = "Все").
//  РежимЗагрузки  - Булево (По умолчанию = Ложь).
// 
// Возвращаемое значение:
//   Булево - Справочник записан.
// 
Функция ЗаписатьСправочник(ТекущийОбъект, Заголовок = "", РежимСообщений = "Все", РежимЗагрузки = Ложь) Экспорт
	
	СправочникЗаписан = Ложь;
	
	РежимыВывода = ОпределитьРежимыВывода(РежимСообщений);
	
	Попытка
		
		Если РежимЗагрузки Тогда
			ТекущийОбъект.ОбменДанными.Загрузка = Истина;
			СправочникЗаписан = Истина;
		Иначе
			СправочникЗаписан = ТекущийОбъект.ПроверитьЗаполнение();
		КонецЕсли;
		
		Если СправочникЗаписан Тогда
			
			ТекущийОбъект.Записать();
			Если РежимыВывода.ВыводитьИнформацию Тогда
				__ОбщегоНазначенияСлужебный.СообщитьПользователю(
					СтрШаблон(НСтр("ru='Записан справочник ""%1"".';en='Directory ""%1"" saved.'"), ТекущийОбъект.Ссылка));
			КонецЕсли;
		КонецЕсли;
	Исключение
		
		СправочникЗаписан = Ложь;
		
		Если РежимыВывода.ВыводитьОшибки Тогда
			__ОбщегоНазначенияСлужебный.СообщитьПользователю(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецЕсли;
		
		ЗаписьЖурналаРегистрации("__.ОшибкаЗаписиСправочника", УровеньЖурналаРегистрации.Ошибка,,,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат СправочникЗаписан;
	
КонецФункции // ЗаписатьСправочник()

// Преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
// 
// Параметры:
//  ТекстXML - Текст в формате XML.
//      Схема XML:
// 			<?xml version="1.0" encoding="utf-8"?>
// 			<xs:schema attributeFormDefault="unqualified" 
// 						elementFormDefault="qualified" xmlns:xs="http:// www.w3.org/2001/XMLSchema">
//			  <xs:element name="Items">
//			 	<xs:complexType>
// 				  <xs:sequence>
// 					<xs:element maxOccurs="unbounded" name="Item">
// 					  <xs:complexType>
// 						<xs:attribute name="Code" type="xs:integer" use="required" />
// 						<xs:attribute name="Name" type="xs:string" use="required" />
// 						<xs:attribute name="Socr" type="xs:string" use="required" />
// 						<xs:attribute name="Index" type="xs:string" use="required" />
// 					  </xs:complexType>
// 					</xs:element>
// 				  </xs:sequence>
// 				  <xs:attribute name="Description" type="xs:string" use="required" />
// 				  <xs:attribute name="Columns" type="xs:string" use="required" />
// 				</xs:complexType>
// 			 </xs:element>
//			 </xs:schema> 
//      Примеры XML-файлов см. в демонстрационной конфигурации.
// 
// Пример использования:
//   КлассификаторТаблица = ПрочитатьXMLВТаблицу(РегистрыСведений.АдресныйКлассификатор.
//       ПолучитьМакет("КлассификаторАдресныхОбъектовРоссии").ПолучитьТекст());
// 
// Возвращаемое значение:
//  ТаблицаЗначений.
// 
Функция ПрочитатьXMLВТаблицу(ТекстXML) Экспорт
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(ТекстXML);
	
	// Прочитаем первый узел и проверим его.
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение("Пустой XML");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение(НСтр("ru='Ошибка в структуре XML';en='Ошибка в структуре XML'"));
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее.
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице.
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение(НСтр("ru='Ошибка в структуре XML';en='Ошибка в структуре XML'"));
		КонецЕсли;
		
		НоваяСтрока = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			НоваяСтрока[Сч - 1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
	КонецЦикла;
	
	Результат = Новый Структура("ИмяТаблицы, Данные", ИмяТаблицы, ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции // ПрочитатьXMLВТаблицу()

// Определяет режимы вывода сообщений.
// 
// Параметры:
//  РежимСообщений - Строка - "Нет", "Все", "Ошибки".
// 
// Возвращаемое значение:
//  Структура - Структура режима вывода сообщений.
//
Функция ОпределитьРежимыВывода(РежимСообщений) Экспорт
	
	РежимыВывода = Новый Структура("ВыводитьОшибки, ВыводитьИнформацию",
		ВРег(РежимСообщений) = ВРег("Все") Или ВРег(РежимСообщений) = ВРег("Ошибки"),
		ВРег(РежимСообщений) = ВРег("Все"));
	
	Возврат РежимыВывода;
	
КонецФункции // ОпределитьРежимВывода()

// Выполняет произвольный код с параметрами.
// 
// Параметры:
//  Текст функции       - Произвольный.
//  СтруктураПараметров - Массив структур (Номер, Значение).
//  Переменные          - Структура - Структура переменных функции.
// 
// Возвращаемое значение:
//   Неопределено, в случае успешного выполнения, Описание ошибки, в случае неудачи.
//
Функция ВыполнитьПользовательскуюФункциюСПараметрами(ТекстФункции, СтруктураПараметров, Переменные) Экспорт
	
	// Служебные переменные для передачи параметров функции.
	Перем П1, П2, П3, П4, П5, П6, П7, П8, П9, П10;
	
	Для Каждого Параметр Из СтруктураПараметров Цикл
		
		Если Параметр.Номер = 1 Тогда
			П1 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П1");
		ИначеЕсли Параметр.Номер = 2 Тогда
			П2 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П2");
		ИначеЕсли Параметр.Номер = 3 Тогда
			П3 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П3");
		ИначеЕсли Параметр.Номер = 4 Тогда
			П4 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П4");
		ИначеЕсли Параметр.Номер = 5 Тогда
			П5 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П5");
		ИначеЕсли Параметр.Номер = 6 Тогда
			П6 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П6");
		ИначеЕсли Параметр.Номер = 7 Тогда
			П7 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П7");
		ИначеЕсли Параметр.Номер = 8 Тогда
			П8 = Параметр.Значение;	
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П8");
		ИначеЕсли Параметр.Номер = 9 Тогда
			П9 = Параметр.Значение;	
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П9");
		ИначеЕсли Параметр.Номер = 10 Тогда
			П10 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П10");
		КонецЕсли;
	КонецЦикла;
	
	Результат = Неопределено;
	
	Попытка
		Выполнить(ТекстФункции);
	Исключение
		ВызватьИсключение КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции // ВыполнитьПользовательскуюФункциюСПараметрами()

// Добавляет новую строку "ДобавляемаяСтрока" к тексту "Текст".
// 
// Параметры:
//  Текст             - Строка - Текущий текст.
//  ДобавляемаяСтрока - Строка - Добавляемая строка.
//
Процедура ДобавитьСтрокуКТексту(Текст, ДобавляемаяСтрока) Экспорт
	
	Текст = СтрШаблон("%1%2%3", Текст, ?(СокрЛП(Текст) = "", "", Символы.ПС), ДобавляемаяСтрока);
	
КонецПроцедуры // ДобавитьСтрокуКТексту()

// По массиву типов создается список выбора для быстрого выбора составного типа.
// 
// Параметры:
//  МассивТипов - Массив - Массив типов.
// 
// Возвращаемое значение:
//  СписокЗначений - Список выбора.
//
Функция ПодготовитьСписокВыбораТипа(МассивТипов) Экспорт
	
	СписокВыбора = Новый СписокЗначений;
	Для Каждого ТекущийТип Из МассивТипов Цикл
		
		ОбъектМетаданных = Метаданные.НайтиПоТипу(ТекущийТип);
		Если ОбъектМетаданных = Неопределено Тогда
			ТекПредставление = Строка(ТекущийТип);
		Иначе
			ТекПредставление = ОбъектМетаданных.Синоним;
		КонецЕсли;
		
		СписокВыбора.Добавить(ТекущийТип,ТекПредставление);
	КонецЦикла;
	
	Возврат СписокВыбора;
	
КонецФункции // ПодготовитьСписокВыбораТипа()

// Функция определяет имя объекта ссылочного типа по описанию типов.
// 
// Параметры:
//  ОписаниеТипов   - ОписаниеТипов - содержит тип, имя объекта которого нужно определить.
//  ИмяКоллекции    - Строка - имя коллекции объектов метаданных: "Справочники","Документы" и т.п.
//  НачалоИмениТипа - Строка - начало строкового представления типа : "СправочникСсылка", "ДокументСсылка" и т.п.
//
// Возвращаемое значение:
//  РезСтруктура   - Структура (Ключи: "Имя","Синоним","ИмяТипа"; Значения: Строка) 
//                   Неопределено (если имя не удалось определить). 
//
Функция ПолучитьИмяОбъектаПоОписаниюТипов(ОписаниеТипов, ИмяКоллекции, НачалоИмениТипа) Экспорт
	
	Результат = Неопределено;
	
	Для Каждого ТекущийОбъект Из Метаданные[ИмяКоллекции] Цикл
		
		ИмяТипа = СтрШаблон("%1.%2", НачалоИмениТипа, ТекущийОбъект.Имя);
		Если ОписаниеТипов.СодержитТип(Тип(ИмяТипа)) Тогда
			
			Результат = Новый Структура;
			Результат.Вставить("Имя", ТекущийОбъект.Имя);
			Результат.Вставить("Синоним", ТекущийОбъект.Синоним);
			Результат.Вставить("ИмяТипа", ИмяТипа);
			
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // ПолучитьИмяОбъектаПоОписаниюТипов()

// Функция получает имя объекта по имени формы.
// 
// Параметры:
//  ИмяФормы - Строка - Имя формы.
//  
// Возвращаемое значение:
//   Строка - Имя объекта.
// 
Функция ПолучитьИмяОбъектаПоИмениФормы(ИмяФормы, ПолноеИмя = Истина) Экспорт
	
	МассивИмениФормы = __СтроковыеФункцииКлиентСервер.РазобратьСтрокуСРазделителями(ИмяФормы, ".");
	Результат = СтрШаблон("%1%2",
		?(ПолноеИмя, СтрШаблон("%1.", МассивИмениФормы.Получить(0)), ""),
		МассивИмениФормы.Получить(1));
		
	Возврат Результат;
	
КонецФункции // ПолучитьИмяОбъектаПоИмениФормы()

#Область ОтладкаВременныхТаблиц

// Функция возвращает все поля указанной временной таблицы из менеджера временных таблиц.
// Используется для просмотра временных таблиц в отладчике.
//
// Параметры:
//  ЗапросМенеджер - Запрос, МенеджерВременныхТаблиц - запрос (для вычленения текста запроса) или менеджер.
//  ИмяВременнойТаблицы - Строка - Имя временной таблицы
// 
// Возвращаемое значение:
//  - ТаблицаЗначений - Результат временной таблицы запроса.
//
// Пример вызова функции:
//    ЗапасыСервер.ПоказатьВременнуюТаблицу(МенеджерВременныхТаблиц, "ТаблицаТоваров")
//
Функция ПоказатьВременнуюТаблицу(ЗапросМенеджер, ИмяВременнойТаблицы) Экспорт
	
	ЗакрытьМенеджерВременныхТаблиц = Ложь;
	
	Если ТипЗнч(ЗапросМенеджер) = Тип("Запрос") Тогда
		Если ЗапросМенеджер.МенеджерВременныхТаблиц = Неопределено Тогда
			МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
			ЗакрытьМенеджерВременныхТаблиц = Истина;
			ЗапросМенеджер.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
		Иначе
			МенеджерВременныхТаблиц = ЗапросМенеджер.МенеджерВременныхТаблиц;
		КонецЕсли;
		
		ЗапросМенеджер.Выполнить();
	Иначе
		МенеджерВременныхТаблиц = ЗапросМенеджер;
	КонецЕсли;
	
	ДанныеТаблицы = ЗапросВыполнитьВыгрузить("ВЫБРАТЬ * ИЗ " + ИмяВременнойТаблицы,, МенеджерВременныхТаблиц);
	
	Если ЗакрытьМенеджерВременныхТаблиц Тогда
		МенеджерВременныхТаблиц.Закрыть();
		ЗапросМенеджер.МенеджерВременныхТаблиц = Неопределено;
	КонецЕсли;
	
	Возврат ДанныеТаблицы;
	
КонецФункции

// Функция возвращает результат запроса.
//
// Параметры:
//  ТекстЗапроса - Строка - текст исполняемого запроса.
//  ПараметрыЗапроса - Соответствие - Соответствие параметров запроса.
//  МенеджерВременныхТаблиц - МенеджерВременныхТаблиц - Менеджер временных таблиц запроса.
// 
// Возвращаемое значение:
//  - ТаблицаЗначений - Результат выполнения запроса.
//
Функция ЗапросВыполнитьВыгрузить(ТекстЗапроса, ПараметрыЗапроса = Неопределено,
	МенеджерВременныхТаблиц = Неопределено) Экспорт
	
	Запрос = Новый Запрос(ТекстЗапроса);
	
	Если МенеджерВременныхТаблиц <> Неопределено Тогда
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПараметрыЗапроса) Тогда
		Для Каждого Параметр Из ПараметрыЗапроса Цикл
			Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// Формирует список полей временных таблиц.
//
// Параметры:
//  ЗапросМенеджер - Запрос, МенеджерВременныхТаблиц - запрос (для вычленения текста запроса) или менеджер 
//		временных таблиц (имена временных таблиц в этом случае надо передавать явно).
//  ИменаВременныхТаблиц	- Строка - строка с именами интересующих временных таблиц (обязательный параметр при передаче 
//		менеджера ВТ вместо запроса в первом параметре).
// 
// Возвращаемое значение:
//  Массив - Поля временных таблицы, находящиеся в менеджере или запросе.
//
// Пример вызова функции:
//      ПросмотрВременныхТаблиц(Запрос, "")
//
Функция ПоляВременныхТаблиц(ЗапросМенеджер, ИменаВременныхТаблиц = "") Экспорт
	
	// Предварительная обработка параметров:
	Если ТипЗнч(ЗапросМенеджер) = Тип("МенеджерВременныхТаблиц") Тогда
		Если ИменаВременныхТаблиц = "" Тогда
			Возврат "Укажите имена временных таблиц через запятую";
		Иначе
			Запрос = Новый Запрос;
			Запрос.МенеджерВременныхТаблиц = ЗапросМенеджер;
		КонецЕсли;
	Иначе
		Запрос = ЗапросМенеджер;
	КонецЕсли;
	
	ТекстЗапроса = ВРег(Запрос.Текст);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, Символы.Таб, " ");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, Символы.ВТаб, " ");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, Символы.НПП, " ");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ")", ") ");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "(", " (");
	
	ОчищенныйТекстЗапроса = "";
	Для НомерСтроки = 1 По СтрЧислоСтрок(ТекстЗапроса) Цикл
		
		ОчереднаяСтрока = СтрПолучитьСтроку(ТекстЗапроса, НомерСтроки);
		ПозицияКомментария = СтрНайти(ОчереднаяСтрока, "//");
		
		Если ПозицияКомментария > 0 Тогда
			ОчереднаяСтрока = Лев(ОчереднаяСтрока,ПозицияКомментария-1);
		КонецЕсли;
		
		ОчищенныйТекстЗапроса = ОчищенныйТекстЗапроса + " " + ОчереднаяСтрока;
	КонецЦикла;
	
	ТекстЗапроса = ОчищенныйТекстЗапроса;
	
	// Парсинг текста запроса и получение из него имен временных таблиц	
	ВременныеТаблицыЗапроса = новый Массив;
	
	Если НЕ ИменаВременныхТаблиц = "" Тогда
		
		СписокДополнительныхИмен = СтрЗаменить(ИменаВременныхТаблиц, ",", Символы.ПС);
		Для Счетчик = 1 По СтрЧислоСтрок(СписокДополнительныхИмен) Цикл
			ТекСтрока = СтрПолучитьСтроку(СписокДополнительныхИмен, Счетчик);
			ВременныеТаблицыЗапроса.Добавить(ТекСтрока);
		КонецЦикла;
		
	КонецЕсли;
	
	ВременнаяТаблица = НайтиИменаТаблицПоРасположениюСлов(ТекстЗапроса, "ПОМЕСТИТЬ");
	Для Каждого КлючЗначение Из ВременнаяТаблица Цикл
		ВременныеТаблицыЗапроса.Добавить(КлючЗначение.Ключ);
	КонецЦикла;
	
	ВременнаяТаблица = НайтиИменаТаблицПоРасположениюСлов(ТекстЗапроса, "ИЗ", "КАК");
	Для Каждого КлючЗначение Из ВременнаяТаблица Цикл
		ВременныеТаблицыЗапроса.Добавить(КлючЗначение.Ключ);
	КонецЦикла;
	
	ВременнаяТаблица = НайтиИменаТаблицПоРасположениюСлов(ТекстЗапроса, "СОЕДИНЕНИЕ", "КАК");
	Для Каждого КлючЗначение Из ВременнаяТаблица Цикл
		ВременныеТаблицыЗапроса.Добавить(КлючЗначение.Ключ);
	КонецЦикла;
	
	УничтожаемыеВременныеТаблицы = НайтиИменаТаблицПоРасположениюСлов(ТекстЗапроса, "УНИЧТОЖИТЬ");
	Для Каждого КлючЗначение Из УничтожаемыеВременныеТаблицы Цикл
		ВременныеТаблицыЗапроса.Добавить(КлючЗначение.Ключ);
	КонецЦикла;
	
	Ответ = Новый Структура;
	
	Если Запрос.МенеджерВременныхТаблиц = Неопределено тогда
		
		// На случай, если ВТ удаляются в тексте запроса, сложнейший алгоритм предварительно скопирует их
		Смещение = 0;
		Если УничтожаемыеВременныеТаблицы.Количество() Тогда
			Для Каждого КлючИЗначение Из УничтожаемыеВременныеТаблицы Цикл
				
				ПозицияУничтожения = КлючИЗначение.Значение + Смещение;
				ИмяВТ = КлючИЗначение.Ключ ;
				НовыйПодзапросКопирования   = "ВЫБРАТЬ * ПОМЕСТИТЬ КОПИЯ" + ИмяВТ + " ИЗ "+ ИмяВТ + ";";
				
				ТекстЗапроса = Лев(ТекстЗапроса, ПозицияУничтожения - 1) + НовыйПодзапросКопирования + Прав(
					ТекстЗапроса, СтрДлина(ТекстЗапроса) - (ПозицияУничтожения - 1));
					
				Смещение = Смещение + НовыйПодзапросКопирования;
			КонецЦикла;
		КонецЕсли;
		
		// Выполняем запрос для создания интересующих нас таблиц
		ЗапросТМП = Новый Запрос;
		ЗапросТМП.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
		Для Каждого Параметр Из Запрос.Параметры Цикл
			ЗапросТМП.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
		КонецЦикла;
		
		ЗапросТМП.Текст = ТекстЗапроса;
		ЗапросТМП.Выполнить();
		
		ЗаполнитьТаблицыПоСпискуИмен(Ответ, ВременныеТаблицыЗапроса, ЗапросТМП.МенеджерВременныхТаблиц);
		
		ЗапросТМП.МенеджерВременныхТаблиц.Закрыть();
		
	Иначе
		
		// Это надо запускать после выполнения запроса, чтобы временные таблицы уже были созданы	
		ОтсутствующиеИменаТаблиц = ЗаполнитьТаблицыПоСпискуИмен(
			Ответ, ВременныеТаблицыЗапроса, Запрос.МенеджерВременныхТаблиц);
		
		Для Каждого ИмяТаблицы Из ОтсутствующиеИменаТаблиц Цикл
			
			Если УничтожаемыеВременныеТаблицы.Получить(ИмяТаблицы) = Неопределено Тогда
				СообщениеОбОшибке = "Таблица еще не создана либо имя задано не верно";
			Иначе
				СообщениеОбОшибке = "Таблица уничтожается при выполнении пакета";
			КонецЕсли;
			
			Ответ.Вставить(ИмяТаблицы, СообщениеОбОшибке);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Ответ;
	
КонецФункции

#КонецОбласти // ОтладкаВременныхТаблиц

// Возвращает массив значений произвольного типа, объекта соответствия.
//
// Параметры:
//  ТипСоответствия	 - СправочникСсылка.__ТипСоответствияОбъектовИБ - Тип соответствия.
//  ИмяКлюча		 - Строка - поле регистра сведений __СоответствияОбъектовИБ, по которому устанавливается отбор. 
//  ЗначениеКлюча	 - ПроизвольныйТип - Значение ключа по которому установлен отбор.
//  ИмяОбъекта		 - Строка - получаемое поле регистра сведений __СоответствияОбъектовИБ.
//  ИспользоватьКэш	 - Булево - Признак получения данных из кэша. 
// 
// Возвращаемое значение:
//   - Массив - Значения объекта из регистра сведений __СоответствияОбъектовИБ, 
//				если соответствие одно в массив будет один элемент 
//
Функция ПолучитьЗначенияОбъектаСоответствияПоКлючу(ТипСоответствия, ИмяКлюча, ЗначениеКлюча, ИмяОбъекта, ИспользоватьКэш = Ложь) Экспорт
	
	Если ИспользоватьКэш Тогда
		Возврат __ОбщегоНазначенияПовтИсп.ПолучитьЗначенияОбъектаСоответствияПоКлючу(
			ТипСоответствия, 
			ИмяКлюча, 
			ЗначениеКлюча, 
			ИмяОбъекта);
	Иначе
		Возврат РегистрыСведений.__СоответствияОбъектовИБ.ПолучитьЗначенияОбъектаСоответствияПоКлючу(
			ТипСоответствия, 
			ИмяКлюча, 
			ЗначениеКлюча, 
			ИмяОбъекта);
	КонецЕсли;
	
КонецФункции

// Возвращает Истину или Ложь, существует ли "Библиотеки стандартных подсистем" (БСП),
// встроенная в конфигурацию.
//
// Возвращаемое значение:
//  Булево - Истина, если БСП существует.
//
Функция СуществуетБиблиотекаСтандартныхПодсистем() Экспорт
	
	ВерсияБСП = Неопределено;
	// Точка входа, где можно попытаться проверить подключена ли БСП
	Если Метаданные.ОбщиеМодули.Найти("СтандартныеПодсистемыСервер") <> Неопределено Тогда
		Попытка
			УстановитьБезопасныйРежим(Истина);
			МодульБСП = ОбщийМодуль("СтандартныеПодсистемыСервер");
			ВерсияБСП = МодульБСП.ВерсияБиблиотеки();
		Исключение
			ВерсияБСП = Неопределено;
		КонецПопытки;
	КонецЕсли;
	
	Возврат ВерсияБСП <> Неопределено;
	
КонецФункции

#Область МетодыАналогиБСП

// Аналог метода БСП. Возвращает ссылку на общий модуль или модуль менеджера по имени.
//
// Параметры:
//  Имя - Строка - имя общего модуля.
//
// Возвращаемое значение:
//   ОбщийМодуль
//   МодульМенеджераОбъекта
//
// Пример:
//	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ОбновлениеКонфигурации") Тогда
//		МодульОбновлениеКонфигурации = ОбщегоНазначения.ОбщийМодуль("ОбновлениеКонфигурации");
//		МодульОбновлениеКонфигурации.<Имя метода>();
//	КонецЕсли;
//
//	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПолнотекстовыйПоиск") Тогда
//		МодульПолнотекстовыйПоискСервер = ОбщегоНазначения.ОбщийМодуль("ПолнотекстовыйПоискСервер");
//		МодульПолнотекстовыйПоискСервер.<Имя метода>();
//	КонецЕсли;
//
Функция ОбщийМодуль(ИмяМодуляБСП, ИмяМодуляВстроенного = "") Экспорт
	
	Имя = ИмяМодуляВстроенного;
	Если __ОбщегоНазначенияПовтИсп.СуществуетБиблиотекаСтандартныхПодсистем()
		И Метаданные.ОбщиеМодули.Найти(ИмяМодуляБСП) <> Неопределено Тогда
		Имя = ИмяМодуляБСП;
	КонецЕсли;
	
	Если Метаданные.ОбщиеМодули.Найти(Имя) <> Неопределено Тогда
		УстановитьБезопасныйРежим(Истина);
		Модуль = Вычислить(Имя);
	ИначеЕсли СтрЧислоВхождений(Имя, ".") = 1 Тогда
		Возврат СерверныйМодульМенеджера(Имя);
	Иначе
		Модуль = Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(Модуль) <> Тип("ОбщийМодуль") Тогда
		ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Общий модуль ""%1"" не существует.'"),
			?(ПустаяСтрока(Имя), ИмяМодуляБСП, Имя));
	КонецЕсли;
	
	Возврат Модуль;
	
КонецФункции

// Аналог метода БСП. Выполнить экспортную процедуру по имени с уровнем привилегий конфигурации.
// При включении профилей безопасности для вызова оператора Выполнить() используется
// переход в безопасный режим с профилем безопасности, используемым для информационной базы
// (если выше по стеку не был установлен другой безопасный режим).
//
// Параметры:
//  ИмяМетода  - Строка - имя экспортной процедуры в формате
//                       <имя объекта>.<имя процедуры>, где <имя объекта> - это
//                       общий модуль или модуль менеджера объекта.
//  Параметры  - Массив - параметры передаются в процедуру <ИмяЭкспортнойПроцедуры>
//                        в порядке расположения элементов массива.
// 
// Пример:
//  Параметры = Новый Массив();
//  Параметры.Добавить("1");
//  ОбщегоНазначения.ВыполнитьМетодКонфигурации("МойОбщийМодуль.МояПроцедура", Параметры);
//
Процедура ВыполнитьМетодКонфигурации(Знач ИмяМетода, Знач Параметры = Неопределено) Экспорт
	
	ПроверитьИмяПроцедурыКонфигурации(ИмяМетода);
	
	УстановитьБезопасныйРежим(Истина);
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл 
			ПараметрыСтрока = ПараметрыСтрока + "Параметры[" + XMLСтрока(Индекс) + "],";
		КонецЦикла;
		ПараметрыСтрока = Сред(ПараметрыСтрока, 1, СтрДлина(ПараметрыСтрока) - 1);
	КонецЕсли;
	
	Выполнить ИмяМетода + "(" + ПараметрыСтрока + ")";
	
КонецПроцедуры

// Аналог метода БСП. Записывает конфиденциальные данные в безопасное хранилище.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Безопасное хранилище недоступно для чтения пользователям (кроме администраторов),
// а доступно только коду, который делает обращения только к своей части данных и
// в том контексте, который предполагает чтение или запись конфиденциальных данных.
//
// Параметры:
//  Владелец - ПланОбменаСсылка
//           - СправочникСсылка
//           - Строка - ссылка на объект информационной базы,
//             представляющий объект-владелец сохраняемого пароля или строка до 128 символов.
//             Для объектов других типов в качестве владельца рекомендуется использовать ссылку на
//             элемент метаданных этого типа в справочнике ИдентификаторыОбъектовМетаданных
//             или ключ в виде строки с учетом имен подсистем.
//             Например, для БСП:
//               Владелец = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("РегистрСведений.АдресныеОбъекты");
//             если нужно 1 хранилище на подсистему БСП:
//               Владелец = "СтандартныеПодсистемы.УправлениеДоступом";
//             если нужно более 1 хранилища на подсистему БСП:
//               Владелец = "СтандартныеПодсистемы.УправлениеДоступом.<Уточнение>";
//  Данные  - Произвольный - данные помещаемые в безопасное хранилище. Неопределенно - удаляет все данные.
//            Для удаления данных по ключу следует использовать процедуру УдалитьДанныеИзБезопасногоХранилища.
//          - Структура - если параметр Ключ содержит Неопределено. Подробнее см. описание параметра Ключ
//  Ключ    - Строка       - ключ сохраняемых настроек, по умолчанию "Пароль".
//                           Ключ должен соответствовать правилам имен идентификаторов:
//                           1. Первым символом ключа должна быть буква или символ подчеркивания (_).
//                           2. Каждый из последующих символов может быть буквой, цифрой или символом подчеркивания (_). 
//            Неопределено - для добавления набора данных структурой, где ключ структуры - это имя ключа данных,
//            а значение - сохраняемые данные. Пример использования см. ниже.
//
// Пример:
//
//  Процедура ПриЗаписиНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
//      Если ТекущийПользовательМожетИзменятьПароль Тогда
//          УстановитьПривилегированныйРежим(Истина);
//          ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище(ТекущийОбъект.Ссылка, Логин, "Логин");
//          ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище(ТекущийОбъект.Ссылка, Пароль);
//          УстановитьПривилегированныйРежим(Ложь);
//      КонецЕсли;
//  КонецПроцедуры
// 
//  Процедура ПриЗаписиНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
//      Если ТекущийПользовательМожетИзменятьПароль Тогда
//          ЛогинИПароль = Новый Структура;
//          ЛогинИПароль.Вставить("Логин", Логин);
//          ЛогинИПароль.Вставить("Пароль", Пароль);
//          УстановитьПривилегированныйРежим(Истина);
//          ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище(ТекущийОбъект.Ссылка, ЛогинИПароль, Неопределено);
//          УстановитьПривилегированныйРежим(Ложь);
//      КонецЕсли;
//  КонецПроцедуры
//
Процедура ЗаписатьДанныеВБезопасноеХранилище(Владелец, Данные, Ключ = "Пароль") Экспорт
	
	__ОбщегоНазначенияСлужебныйКлиентСервер.Проверить(ЗначениеЗаполнено(Владелец),
		__СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Недопустимое значение параметра %1 в %2.
			           |параметр должен содержать ссылку; передано значение: %3 (тип %4).'"),
			"Владелец", "ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище", Владелец, ТипЗнч(Владелец)));
	
	Если ЗначениеЗаполнено(Ключ) Тогда
		
		__ОбщегоНазначенияСлужебныйКлиентСервер.Проверить(ТипЗнч(Ключ) = Тип("Строка"),
			__СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Недопустимое значение параметра %1 в %2.
			|параметр должен содержать строку; передано значение: %3 (тип %4).'"),
			"Ключ", "ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище", Ключ, ТипЗнч(Ключ))); 
	
	Иначе
		
		__ОбщегоНазначенияСлужебныйКлиентСервер.Проверить(ТипЗнч(Данные) = Тип("Структура"),
			__СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Недопустимое значение параметра %1 в %2.
			|Если Ключ = Неопределено, то параметр должен содержать структуру; передано значение: %3 (тип %4).'"),
			"Данные", "ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище", Данные, ТипЗнч(Данные)));
	
	КонецЕсли;
	
	// Загулшка.
	// Перенаправление в хранилище общих настроек, не используется регистр сведений БезопасноеХранилищеДанных
	ХранилищеОбщихНастроекСохранить(Владелец, Ключ, Данные);
	Возврат;
	// Загулшка
	
КонецПроцедуры

// Аналог метода БСП. Возвращает данные из безопасного хранилища.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Безопасное хранилище недоступно для чтения пользователям (кроме администраторов),
// а доступно только коду, который делает обращения только к своей части данных и
// в том контексте, который предполагает чтение или запись конфиденциальных данных.
//
// Параметры:
//  Владелец    - ПланОбменаСсылка
//              - СправочникСсылка
//              - Строка - ссылка на объект информационной базы,
//                  представляющий объект-владелец сохраняемого пароля или уникальная строка(до 128 символов).
//  Ключи       - Строка - содержит список имен сохраненных данных, указанных через запятую.
//              - Неопределено - будут возвращены все сохраненные данные владельца.
//  ОбщиеДанные - Булево - Истина, если требуется в модели сервиса получить данные из общих данных в разделенном режиме.
// 
// Возвращаемое значение:
//  Произвольный, Структура, Неопределено - данные из безопасного хранилища. Если указан один ключ,
//                            то возвращается его значение, иначе структура.
//                            Если данные отсутствуют - Неопределенно.
//
// Пример:
//	Если ТекущийПользовательМожетИзменятьПароль Тогда
//		УстановитьПривилегированныйРежим(Истина);
//		Логин  = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(ТекущийОбъект.Ссылка, "Логин");
//		Пароль = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(ТекущийОбъект.Ссылка);
//		УстановитьПривилегированныйРежим(Ложь);
//	Иначе
//		Элементы.ГруппаЛогинИПароль.Видимость = Ложь;
//	КонецЕсли;
//	
//	УстановитьПривилегированныйРежим(Истина);
//	ЛогинИПароль  = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(ТекущийОбъект.Ссылка, Неопределено);
//
Функция ПрочитатьДанныеИзБезопасногоХранилища(Владелец, Ключи = "Пароль", ОбщиеДанные = Неопределено) Экспорт
	
	// Загулшка.
	// Перенаправление в хранилище общих настроек, не используется регистр сведений БезопасноеХранилищеДанных
	Результат = ХранилищеОбщихНастроекЗагрузить(Владелец, Ключи, ОбщиеДанные);
	Возврат Результат;
	// Загулшка
	
КонецФункции

// Аналог метода БСП. Формирует и выводит сообщение, которое может быть связано с элементом управления формы.
//
// В фоновом задании длительной операции, если вызов выполнен вне транзакции,
// сообщение записывается в служебный регистр и отправляется сразу на клиент,
// если подключена система взаимодействия.
// В конце фонового задания длительной операции, а также при отправке прогресса,
// все сообщения извлекаются из очереди сообщений фонового задания,
// записываются в служебный регистр и отправляются сразу на клиент,
// если подключена система взаимодействия.
//
// АПК:142-выкл 4 необязательных параметра для совместимости 
// с устаревшей процедурой ОбщегоНазначенияКлиентСервер.СообщитьПользователю.
//
// Параметры:
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных - ЛюбаяСсылка - объект или ключ записи информационной базы, к которому это сообщение относится.
//  Поле - Строка - наименование реквизита формы.
//  ПутьКДанным - Строка - путь к данным (путь к реквизиту формы).
//  Отказ - Булево - выходной параметр, всегда устанавливается в значение Истина.
//
// Пример:
//
//  1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ПолеВРеквизитеФормыОбъект",
//   "Объект");
//
//  Альтернативный вариант использования в форме объекта:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "Объект.ПолеВРеквизитеФормыОбъект");
//
//  2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ИмяРеквизитаФормы");
//
//  3. Для вывода сообщения связанного с объектом информационной базы:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
//  4. Для вывода сообщения по ссылке на объект информационной базы:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
//  Случаи некорректного использования:
//   1. Передача одновременно параметров КлючДанных и ПутьКДанным.
//   2. Передача в параметре КлючДанных значения типа отличного от допустимого.
//   3. Установка ссылки без установки поля (и/или пути к данным).
//
Процедура СообщитьПользователю(Знач ТекстСообщенияПользователю, Знач КлючДанных = Неопределено,	Знач Поле = "",
	Знач ПутьКДанным = "", Отказ = Ложь) Экспорт
	
	ЭтоОбъект = Ложь;
	
	Если КлючДанных <> Неопределено
		И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = СтрНайти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
	
	Сообщение = __ОбщегоНазначенияСлужебныйКлиентСервер.СообщениеПользователю(ТекстСообщенияПользователю,
		КлючДанных, Поле, ПутьКДанным, Отказ, ЭтоОбъект);
	
	Сообщение.Сообщить();
	
КонецПроцедуры

// Аналог метода БСП. Сокращает строку до нужной длины, при этом обрезанная часть хешируется,
// обеспечивая уникальность строки. Проверяет длину строки на входе и, в случае
// превышения максимальной длины, преобразует ее конец по алгоритму MD5 в
// уникальную строку из 32 символов.
//
// Параметры:
//  Строка            - Строка - исходная строка произвольной длины.
//  МаксимальнаяДлина - Число  - требуемое максимальное количество символов в строке,
//                               минимальное значение: 32.
// 
// Возвращаемое значение:
//   Строка - строка, не превышающая максимальную длину.
//
Функция СократитьСтрокуКонтрольнойСуммой(Строка, МаксимальнаяДлина) Экспорт
	
	Если МаксимальнаяДлина < 32 Тогда
		__ОбщегоНазначенияСлужебныйКлиентСервер.Проверить(Ложь, 
		__СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Параметр %1 не может быть меньше 32.'"),
			"МаксимальнаяДлина"), "ОбщегоНазначения.СократитьСтрокуКонтрольнойСуммой");
	КонецЕсли;
	
	Результат = Строка;
	Если СтрДлина(Строка) > МаксимальнаяДлина Тогда
		Результат = Лев(Строка, МаксимальнаяДлина - 32);
		ХешированиеДанных = Новый ХешированиеДанных(ХешФункция.MD5);
		ХешированиеДанных.Добавить(Сред(Строка, МаксимальнаяДлина - 32 + 1));
		Результат = Результат + СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

#Область ХранилищеНастроек

// Аналог метода БСП. Загружает настройку из хранилища общих настроек, как метод платформы Загрузить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Кроме того, возвращает указанное значение по умолчанию, если настройки не существуют.
// Если нет права СохранениеДанныхПользователя, возвращается значение по умолчанию без ошибки.
//
// В возвращаемом значении очищаются ссылки на несуществующий объект в базе данных, а именно
// - возвращаемая ссылка заменяется на указанное значение по умолчанию;
// - из данных типа Массив ссылки удаляются;
// - у данных типа Структура и Соответствие ключ не меняется, а значение устанавливается Неопределено;
// - анализ значений в данных типа Массив, Структура, Соответствие выполняется рекурсивно.
//
// Параметры:
//   КлючОбъекта          - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек         - Строка           - см. синтакс-помощник платформы.
//   ЗначениеПоУмолчанию  - Произвольный     - значение, которое возвращается, если настройки не существуют.
//                                             Если не указано, возвращается значение Неопределено.
//   ОписаниеНастроек     - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя      - Строка           - см. синтакс-помощник платформы.
//
// Возвращаемое значение: 
//   Произвольный - см. синтакс-помощник платформы.
//
Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено, 
			ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ЗначениеПоУмолчанию,
		ОписаниеНастроек,
		ИмяПользователя);
	
КонецФункции

// Аналог метода БСП. Сохраняет настройку в хранилище общих настроек, как метод платформы Сохранить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, сохранение пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта       - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек      - Строка           - см. синтакс-помощник платформы.
//   Настройки         - Произвольный     - см. синтакс-помощник платформы.
//   ОписаниеНастроек  - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя   - Строка           - см. синтакс-помощник платформы.
//   ОбновитьПовторноИспользуемыеЗначения - Булево - выполнить одноименный метод платформы.
//
Процедура ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Настройки,
			ОписаниеНастроек = Неопределено,
			ИмяПользователя = Неопределено,
			ОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		Настройки,
		ОписаниеНастроек,
		ИмяПользователя,
		ОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

#КонецОбласти

// Аналог метода БСП. Пока заглушка, см. ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания
Процедура ПриНачалеВыполненияРегламентногоЗадания(РегламентноеЗадание = Неопределено) Экспорт
КонецПроцедуры

// Аналог метода БСП. Возвращает структуру, содержащую значения реквизитов, прочитанные из информационной базы по ссылке на объект.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//            - Строка      - полное имя предопределенного элемента, значения реквизитов которого необходимо получить.
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//                       требований к свойствам структуры.
//                       Например, "Код, Наименование, Родитель".
//            - Структура
//            - ФиксированнаяСтруктура - в качестве ключа передается
//                       псевдоним поля для возвращаемой структуры с результатом, а в качестве
//                       значения (опционально) фактическое имя поля в таблице.
//                       Если ключ задан, а значение не определено, то имя поля берется из ключа.
//                       Допускается указание имени поля через точку, но при этом параметр КодЯзыка для такого поля
//                       учитываться не будет.
//            - Массив из Строка
//            - ФиксированныйМассив из Строка - имена реквизитов в формате требований к свойствам структуры.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя;
//                                если есть ограничение на уровне записей, то все реквизиты вернутся со 
//                                значением Неопределено; если нет прав для работы с таблицей, то возникнет исключение;
//                                если Ложь, то возникнет исключение при отсутствии прав на таблицу 
//                                или любой из реквизитов.
//  КодЯзыка - Строка - код языка для мультиязычного реквизита. Значение по умолчанию - основной язык конфигурации.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если в параметр Реквизиты передана пустая строка, то возвращается пустая структура.
//              Если в параметр Ссылка передана пустая ссылка, то возвращается структура, 
//              соответствующая именам реквизитов со значениями Неопределено.
//              Если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка), 
//              то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты, ВыбратьРазрешенные = Ложь, Знач КодЯзыка = Неопределено) Экспорт
	
	// Если передано имя предопределенного.
	Если ТипЗнч(Ссылка) = Тип("Строка") Тогда
		
		ПолноеИмяПредопределенногоЭлемента = Ссылка;
		
		// Вычисление ссылки по имени предопределенного.
		// - дополнительно выполняет проверку метаданных предопределенного, выполняется предварительно.
		Попытка
			Ссылка = ПредопределенноеЗначение(ПолноеИмяПредопределенногоЭлемента);
		Исключение
			ТекстОшибки = __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный первый параметр %1 в функции %2:
				|%3'"), "Ссылка", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", 
				ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
			ВызватьИсключение ТекстОшибки;
		КонецПопытки;
		
		// Разбор полного имени предопределенного.
		ЧастиПолногоИмени = СтрРазделить(ПолноеИмяПредопределенногоЭлемента, ".");
		ПолноеИмяОбъектаМетаданных = ЧастиПолногоИмени[0] + "." + ЧастиПолногоИмени[1];
		
		// Если предопределенный не создан в ИБ, то требуется выполнить проверку доступа к объекту.
		// В других сценариях проверка доступа выполняется в момент исполнения запроса.
		Если Ссылка = Неопределено Тогда 
			МетаданныеОбъекта = ОбъектМетаданныхПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
			Если Не ПравоДоступа("Чтение", МетаданныеОбъекта) Тогда 
				ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Недостаточно прав для работы с таблицей ""%1""'"), ПолноеИмяОбъектаМетаданных);
			КонецЕсли;
		КонецЕсли;
		
	Иначе // Если передана ссылка.
		
		Попытка
			ПолноеИмяОбъектаМетаданных = Ссылка.Метаданные().ПолноеИмя(); 
		Исключение
			ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный первый параметр %1 в функции %2: 
					|Значение должно быть ссылкой или именем предопределенного элемента.'"), 
				"Ссылка", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта");
		КонецПопытки;
		
	КонецЕсли;
	
	// Разбор реквизитов, если второй параметр Строка.
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		
		Реквизиты = СтрРазделить(Реквизиты, ",", Ложь);
		Для Индекс = 0 По Реквизиты.ВГраница() Цикл
			Реквизиты[Индекс] = СокрЛП(Реквизиты[Индекс]);
		КонецЦикла;
	КонецЕсли;
	
	// Приведение реквизитов к единому формату.
	СтруктураПолей = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип("Структура")
		Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		
		Для Каждого КлючИЗначение Из Реквизиты Цикл
			СтруктураПолей.Вставить(КлючИЗначение.Ключ, СокрЛП(КлючИЗначение.Значение));
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив")
		Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		
		Для Каждого Реквизит Из Реквизиты Цикл
			Реквизит = СокрЛП(Реквизит);
			Попытка
				ПсевдонимПоля = СтрЗаменить(Реквизит, ".", "");
				СтруктураПолей.Вставить(ПсевдонимПоля, Реквизит);
			Исключение 
				// Если псевдоним не является ключом.
				
				// Поиск ошибки доступности полей.
				Результат = ПроверитьСуществованиеРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
				Если Результат.Ошибка Тогда 
					ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Неверный второй параметр %1 в функции %2: %3'"),
						"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", Результат.ОписаниеОшибки);
				КонецЕсли;
				
				// Не удалось распознать ошибку, проброс первичной ошибки.
				ВызватьИсключение;
			
			КонецПопытки;
		КонецЦикла;
	Иначе
		ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный тип второго параметра %1 в функции %2: %3.'"), 
			"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	// Подготовка результата (после выполнения запроса переопределится).
	Результат = Новый Структура;
	
	// Формирование текста запроса к выбираемым полям.
	ТекстЗапросаПолей = "";
	Для каждого КлючИЗначение Из СтруктураПолей Цикл
		
		ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
						КлючИЗначение.Значение,
						КлючИЗначение.Ключ);
		ПсевдонимПоля = КлючИЗначение.Ключ;
	
		ТекстЗапросаПолей = 
			ТекстЗапросаПолей + ?(ПустаяСтрока(ТекстЗапросаПолей), "", ",") + "
			|	" + ИмяПоля + " КАК " + ПсевдонимПоля;
		
		// Предварительное добавление поля по псевдониму в возвращаемый результат.
		Результат.Вставить(ПсевдонимПоля);
		
	КонецЦикла;
	
	// Если предопределенного нет в ИБ.
	// - приведение результата к отсутствию объекта в ИБ или передаче пустой ссылки.
	Если Ссылка = Неопределено Тогда 
		Возврат Результат;
	КонецЕсли;
	
	Если Тип("Структура") = ТипЗнч(Реквизиты)
		Или Тип("ФиксированнаяСтруктура") = ТипЗнч(Реквизиты) Тогда
		Реквизиты = Новый Массив;
		Для Каждого КлючИЗначение Из СтруктураПолей Цикл
			ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
						КлючИЗначение.Значение,
						КлючИЗначение.Ключ);
			Реквизиты.Добавить(ИмяПоля);
		КонецЦикла;
	КонецЕсли;
	
	РеквизитыЧерезТочку = Новый Массив;
	Для Индекс = -Реквизиты.ВГраница() По 0 Цикл
		ИмяПоля = Реквизиты[-Индекс];
		Если СтрНайти(ИмяПоля, ".") Тогда
			РеквизитыЧерезТочку.Добавить(ИмяПоля);
			Реквизиты.Удалить(-Индекс);
		КонецЕсли;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(Реквизиты) Тогда
		ЗначенияРеквизитовОбъекта = ЗначенияРеквизитовОбъектов(__ОбщегоНазначенияСлужебныйКлиентСервер.ЗначениеВМассиве(Ссылка), Реквизиты, ВыбратьРазрешенные, КодЯзыка)[Ссылка];
		Если ЗначенияРеквизитовОбъекта <> Неопределено Тогда
			Для Каждого КлючИЗначение Из СтруктураПолей Цикл
				ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
							КлючИЗначение.Значение,
							КлючИЗначение.Ключ);
				Если СтрНайти(ИмяПоля, ".") = 0 И ЗначенияРеквизитовОбъекта.Свойство(ИмяПоля) Тогда
					Результат[КлючИЗначение.Ключ] = ЗначенияРеквизитовОбъекта[ИмяПоля];
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(РеквизитыЧерезТочку) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Реквизиты = РеквизитыЧерезТочку;
	
	ТекстЗапроса = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|&ТекстЗапросаПолей
		|ИЗ
		|	&ПолноеИмяОбъектаМетаданных КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка";
	
	Если Не ВыбратьРазрешенные Тогда 
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "РАЗРЕШЕННЫЕ", ""); // @Query-part-1
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекстЗапросаПолей", ТекстЗапросаПолей);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПолноеИмяОбъектаМетаданных", ПолноеИмяОбъектаМетаданных);
	
	// Выполнение запроса.
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст = ТекстЗапроса;
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		
		// Если реквизиты были переданы строкой, то они уже конвертированы в массив.
		// Если реквизиты - массив, оставляем без изменений.
		// Если реквизиты - структура - конвертируем в массив.
		// В остальных случаях уже было бы выброшено исключение.
		Если Тип("Структура") = ТипЗнч(Реквизиты)
			Или Тип("ФиксированнаяСтруктура") = ТипЗнч(Реквизиты) Тогда
			Реквизиты = Новый Массив;
			Для каждого КлючИЗначение Из СтруктураПолей Цикл
				ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
							КлючИЗначение.Значение,
							КлючИЗначение.Ключ);
				Реквизиты.Добавить(ИмяПоля);
			КонецЦикла;
		КонецЕсли;
		
		// Поиск ошибки доступности полей.
		Результат = ПроверитьСуществованиеРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
		Если Результат.Ошибка Тогда 
			ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный второй параметр %1 в функции %2: %3'"), 
				"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", Результат.ОписаниеОшибки);
		КонецЕсли;
		
		// Не удалось распознать ошибку, проброс первичной ошибки.
		ВызватьИсключение;
		
	КонецПопытки;
	
	// Заполнение реквизитов.
	Если Выборка.Следующий() Тогда
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Аналог метода БСП. Возвращает значения реквизитов, прочитанные из информационной базы для нескольких объектов.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Если передано имя несуществующего реквизита, то вызывается исключение "Поле объекта не существует". 
//
// Параметры:
//  Ссылки - Массив из ЛюбаяСсылка
//         - ФиксированныйМассив из ЛюбаяСсылка - ссылки на объекты.
//           Если массив пуст, то результатом будет пустое соответствие.
//  Реквизиты - Строка - имена реквизитов перечисленные через запятую, в формате требований к свойствам
//                       структуры. Например, "Код, Наименование, Родитель".
//            - Массив из Строка
//            - ФиксированныйМассив из Строка - имена реквизитов в формате требований к свойствам структуры.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объектам выполняется с учетом прав пользователя;
//                                если какой-либо объект будет исключен из выборки по правам, то этот объект
//                                будет исключен и из результата;
//                                если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//  КодЯзыка - Строка - код языка для мультиязычного реквизита. Значение по умолчанию - основной язык конфигурации.
//
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - список объектов и значений их реквизитов:
//   * Ключ - ЛюбаяСсылка - ссылка на объект;
//   * Значение - Структура:
//    ** Ключ - Строка - имя реквизита;
//    ** Значение - Произвольный - значение реквизита.
// 
Функция ЗначенияРеквизитовОбъектов(Ссылки, Знач Реквизиты, ВыбратьРазрешенные = Ложь, Знач КодЯзыка = Неопределено) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		Реквизиты = СтрСоединить(Реквизиты, ",");
	КонецЕсли;
	
	Если ПустаяСтрока(Реквизиты) Тогда 
		ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный второй параметр %1 в функции %2: 
				|Поле объекта должно быть указано.'"), "Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов");
	КонецЕсли;
	
	Если СтрНайти(Реквизиты, ".") <> 0 Тогда 
		ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный второй параметр %1 в функции %2: 
				|Обращение через точку не поддерживается.'"), "Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов");
	КонецЕсли;
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если Ссылки.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(КодЯзыка) Тогда
		КодЯзыка = СтрРазделить(КодЯзыка, "_", Истина)[0];
	КонецЕсли;
	
	РеквизитыТекстЗапроса = Реквизиты;
	
	СсылкиПоТипам = Новый Соответствие;
	Для Каждого Ссылка Из Ссылки Цикл
		Тип = ТипЗнч(Ссылка);
		Если СсылкиПоТипам[Тип] = Неопределено Тогда
			СсылкиПоТипам[Тип] = Новый Массив;
		КонецЕсли;
		ЭлементПоТипу = СсылкиПоТипам[Тип]; // Массив
		ЭлементПоТипу.Добавить(Ссылка);
	КонецЦикла;
	
	ТекстыЗапросов = Новый Массив;
	ПараметрыЗапроса = Новый Структура;
	
	ИменаОбъектовМетаданных = Новый Массив;
	
	Для Каждого СсылкиПоТипу Из СсылкиПоТипам Цикл
		Тип = СсылкиПоТипу.Ключ;
		ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
		Если ОбъектМетаданных = Неопределено Тогда
			ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный первый параметр %1 в функции %2: 
					|Значения массива должны быть ссылками.'"), "Ссылки", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов");
		КонецЕсли;
		
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
		ИменаОбъектовМетаданных.Добавить(ПолноеИмяОбъектаМетаданных);
		
		ТекстЗапроса =
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	Ссылка,
			|	&Реквизиты
			|ИЗ
			|	&ПолноеИмяОбъектаМетаданных КАК ПсевдонимЗаданнойТаблицы
			|ГДЕ
			|	ПсевдонимЗаданнойТаблицы.Ссылка В (&Ссылки)";
		Если Не ВыбратьРазрешенные Или ТекстыЗапросов.Количество() > 0 Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "РАЗРЕШЕННЫЕ", ""); // @Query-part-1
		КонецЕсли;
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Реквизиты", РеквизитыТекстЗапроса);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПолноеИмяОбъектаМетаданных", ПолноеИмяОбъектаМетаданных);
		ИмяПараметра = "Ссылки" + СтрЗаменить(ПолноеИмяОбъектаМетаданных, ".", "");
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Ссылки", "&" + ИмяПараметра); // @Query-part-1
		ПараметрыЗапроса.Вставить(ИмяПараметра, СсылкиПоТипу.Значение);
		
		ТекстыЗапросов.Добавить(ТекстЗапроса);
	КонецЦикла;
	
	ТекстЗапроса = СтрСоединить(ТекстыЗапросов, Символы.ПС + "ОБЪЕДИНИТЬ ВСЕ" + Символы.ПС);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("КодЯзыка", КодЯзыка);
	Для Каждого Параметр Из ПараметрыЗапроса Цикл
		Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
	КонецЦикла;
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		
		// Удаление пробелов.
		Реквизиты = СтрЗаменить(Реквизиты, " ", "");
		// Преобразование параметра в массив полей.
		Реквизиты = СтрРазделить(Реквизиты, ",");
		
		// Поиск ошибки доступности полей.
		СписокОшибок = Новый Массив;
		Для Каждого ПолноеИмяОбъектаМетаданных Из ИменаОбъектовМетаданных Цикл
			Результат = ПроверитьСуществованиеРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
			Если Результат.Ошибка Тогда 
				СписокОшибок.Добавить(Результат.ОписаниеОшибки);
			КонецЕсли;
		КонецЦикла;
		
		Если ЗначениеЗаполнено(СписокОшибок) Тогда
			ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный второй параметр %1 в функции %2: %3'"), 
				"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов", СтрСоединить(СписокОшибок, Символы.ПС));
		КонецЕсли;
		
		// Не удалось распознать ошибку, проброс первичной ошибки.
		ВызватьИсключение;
		
	КонецПопытки;
	
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(Реквизиты);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
		
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Аналог метода БСП. Возвращает ОбъектМетаданных, быстро найденный по полному имени.
// Более производительный аналог метода платформы Метаданные.НайтиПоПолномуИмени
// для корневых объектов метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, например, Справочник.Организации
//
// Возвращаемое значение:
//  ОбъектМетаданных - когда найден
//  Неопределено - когда не найден
//
Функция ОбъектМетаданныхПоПолномуИмени(ПолноеИмя) Экспорт
	
	ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
	
	Возврат ОбъектМетаданных;
	
КонецФункции

// Аналог метода БСП. Проверяет существование указанных реквизитов у объекта метаданных.
// 
// Параметры:
//  ПолноеИмяОбъектаМетаданных - Строка - полное имя проверяемого объекта.
//  ПроверяемыеВыражения       - Массив - имена полей или проверяемые выражения объекта метаданных.
// 
// Возвращаемое значение:
//  Структура:
//   * Ошибка         - Булево - найдена ошибка.
//   * ОписаниеОшибки - Строка - описание найденных ошибок.
//
// Пример:
//  
// Реквизиты = Новый Массив;
// Реквизиты.Добавить("Номер");
// Реквизиты.Добавить("Валюта.НаименованиеПолное");
//
// Результат = ОбщегоНазначения.ПроверитьСуществованиеРеквизитовОбъекта("Документ._ДемоЗаказПокупателя", Реквизиты);
//
// Если Результат.Ошибка Тогда
//     ВызватьИсключение Результат.ОписаниеОшибки;
// КонецЕсли;
//
Функция ПроверитьСуществованиеРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, ПроверяемыеВыражения)
	
	МетаданныеОбъекта = ОбъектМетаданныхПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
	Если МетаданныеОбъекта = Неопределено Тогда 
		Возврат Новый Структура("Ошибка, ОписаниеОшибки", Истина, 
			__СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Несуществующий объект метаданных ""%1"".'"), ПолноеИмяОбъектаМетаданных));
	КонецЕсли;

	// Разрешение вызова из безопасного режима внешней обработки или расширения.
	// Информация о доступности полей источника схемы при проверке метаданных не является секретной.
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Схема = Новый СхемаЗапроса;
	Пакет = Схема.ПакетЗапросов.Добавить(Тип("ЗапросВыбораСхемыЗапроса"));
	Оператор = Пакет.Операторы.Получить(0);
	
	Источник = Оператор.Источники.Добавить(ПолноеИмяОбъектаМетаданных, "Таблица");
	ТекстОшибки = "";
	
	Возврат Новый Структура("Ошибка, ОписаниеОшибки", Не ПустаяСтрока(ТекстОшибки), ТекстОшибки);
	
КонецФункции

// Аналог метода БСП. Создает объект ОписаниеТипов, содержащий тип Строка.
//
// Параметры:
//  ДлинаСтроки - Число - длина строки.
//
// Возвращаемое значение:
//  ОписаниеТипов - описание типа Строка.
//
Функция ОписаниеТипаСтрока(ДлинаСтроки) Экспорт
	
	Возврат Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(ДлинаСтроки));
	
КонецФункции

// Аналог метода БСП. Создает объект ОписаниеТипов, содержащий тип Число.
//
// Параметры:
//  Разрядность - Число - общее количество разрядов числа (количество разрядов
//                        целой части плюс количество разрядов дробной части).
//  РазрядностьДробнойЧасти - Число - число разрядов дробной части.
//  ЗнакЧисла - ДопустимыйЗнак - допустимый знак числа.
//
// Возвращаемое значение:
//  ОписаниеТипов - описание типа Число.
//
Функция ОписаниеТипаЧисло(Разрядность, РазрядностьДробнойЧасти = 0, Знач ЗнакЧисла = Неопределено) Экспорт
	
	Если ЗнакЧисла = Неопределено Тогда 
		ЗнакЧисла = ДопустимыйЗнак.Любой;
	КонецЕсли;
	
	Возврат Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла));
	
КонецФункции

// Аналог метода БСП. Возвращает значение настройки рабочей даты для пользователя или текущей даты сеанса,
// если рабочая дата пользователя не задана.
//
// Параметры:
//  ИмяПользователя - Строка - имя пользователя, для которого запрашивается рабочая дата.
//		Если не задано, то устанавливается для текущего пользователя.
//
// Возвращаемое значение:
//  Дата - значение настройки рабочей даты пользователя или текущая дата сеанса, если настройка не задана.
//
Функция ТекущаяДатаПользователя(ИмяПользователя = Неопределено) Экспорт

	Возврат ТекущаяДатаСеанса();
	
КонецФункции

#КонецОбласти

#КонецОбласти // ПрограммныйИнтерфейс

#Область СлужебныеПроцедурыИФункции

Функция ЗаполнитьТаблицыПоСпискуИмен(СтруктураОтвета, МассивИменТаблиц, Менеджер)
	
	ОтсутствующиеИменаТаблиц = Новый Массив;
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Менеджер;
	
	Для Каждого ИмяТаблицы Из МассивИменТаблиц Цикл
		Если НЕ СтруктураОтвета.Свойство(ИмяТаблицы) Тогда
			
			Запрос.Текст = "ВЫБРАТЬ * ИЗ " + ИмяТаблицы + " КАК " + ИмяТаблицы;
			Попытка
				СтруктураОтвета.Вставить(ИмяТаблицы, Запрос.Выполнить().Выгрузить());
			Исключение
				СтруктураОтвета.Вставить(ИмяТаблицы, ОписаниеОшибки());
				ОтсутствующиеИменаТаблиц.Добавить(ИмяТаблицы);
			КонецПопытки;
			
		КонецЕсли;
	КонецЦикла;
	
	Возврат ОтсутствующиеИменаТаблиц;
	
КонецФункции

Функция НайтиИменаТаблицПоРасположениюСлов(Знач Текст, ПервоеИскомоеСлово, ВтороеИскомоеСлово = "")
	
	СписокИгнорируемыхСимволов = Новый СписокЗначений;
	СписокИгнорируемыхСимволов.Добавить(Символы.ПС);
	СписокИгнорируемыхСимволов.Добавить(Символы.ВК);
	СписокИгнорируемыхСимволов.Добавить(Символы.НПП);
	СписокИгнорируемыхСимволов.Добавить(Символы.Таб);
	СписокИгнорируемыхСимволов.Добавить(" ");
	
	СписокРазделителей = Новый СписокЗначений;
	СписокРазделителей.Добавить("(");
	СписокРазделителей.Добавить(")");
	СписокРазделителей.Добавить(".");
	СписокРазделителей.Добавить(",");
	СписокРазделителей.Добавить(";");
	СписокРазделителей.Добавить("&");
	
	НайденныеИмена = Новый Структура;
	ПервоеИскомоеСлово = ВРег(ПервоеИскомоеСлово);
	ВтороеИскомоеСлово = ВРег(ВтороеИскомоеСлово);
	
	Пока Истина Цикл
		
		Найдено = Найти(Текст, " " + ВРег(ПервоеИскомоеСлово) + " ");
		Если Найдено > 0 Тогда
			
			Текст = СокрЛП(Прав(Текст, СтрДлина(Текст) - Найдено - СтрДлина(ПервоеИскомоеСлово) - 1));
			СоставляемоеСлово = "";
			НайденноеСлово = "";
			
			Для НомерСтроки = 1 По СтрДлина(Текст) Цикл
				
				ОчереднойСимвол = Сред(Текст, НомерСтроки, 1);
				
				Если НЕ СписокРазделителей.НайтиПоЗначению(ОчереднойСимвол) = Неопределено Тогда
					
					СоставляемоеСлово = "";
					НайденноеСлово = "";
					
					Прервать;
					
				ИначеЕсли НЕ СписокИгнорируемыхСимволов.НайтиПоЗначению(ОчереднойСимвол) = Неопределено Тогда
					
					Если СоставляемоеСлово = "" Тогда
						Продолжить;
					Иначе
						Если НайденноеСлово = "" Тогда
							
							НайденноеСлово = СоставляемоеСлово;
							СоставляемоеСлово = "";
							
							Если ВтороеИскомоеСлово = "" Тогда
								Прервать;
							КонецЕсли;
							
						Иначе
							
							Если НЕ СоставляемоеСлово = ВтороеИскомоеСлово Тогда
								НайденноеСлово = "";
							КонецЕсли;
							
							Прервать;
							
						КонецЕсли;
					КонецЕсли;
				Иначе
					СоставляемоеСлово = СоставляемоеСлово + ОчереднойСимвол;
				КонецЕсли;
				
			КонецЦикла;
			
			Если НЕ НайденноеСлово = "" Тогда
				НайденныеИмена.Вставить(НайденноеСлово, Найдено);
			КонецЕсли;
		Иначе
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НайденныеИмена;
	
КонецФункции

#Область МетодыАналогиБСП

#Область БезопасноеВыполнениеВнешнегоКода

// Аналог метода БСП. Проверяет, что переданное имя ИмяПроцедуры является именем экспортной процедуры конфигурации.
// Может использоваться для проверки, что переданная строка не содержит произвольного алгоритма
// на встроенном языке 1С:Предприятия перед использованием его в операторах Выполнить и Вычислить
// при их использовании для динамического вызова методов код конфигурации.
//
// В случае если переданная строка не является именем процедуры конфигурации, генерируется исключение.
//
// Предназначена для вызова из см. процедуру ВыполнитьМетодКонфигурации.
//
// Параметры:
//   ИмяПроцедуры - Строка - проверяемое имя экспортной процедуры.
//
Процедура ПроверитьИмяПроцедурыКонфигурации(Знач ИмяПроцедуры)
	
	ЧастиИмени = СтрРазделить(ИмяПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
		ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра %1 (передано значение: ""%2"") в %3.'"), 
			"ИмяПроцедуры", ИмяПроцедуры, "ОбщегоНазначения.ВыполнитьМетодКонфигурации");
	КонецЕсли;
	
	ИмяОбъекта = ЧастиИмени[0];
	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
		ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра %1 (передано значение: ""%2"") в %3:
				|Не существует общий модуль ""%4"".'"),
			"ИмяПроцедуры", ИмяПроцедуры, "ОбщегоНазначения.ВыполнитьМетодКонфигурации", ИмяОбъекта);
	КонецЕсли;
	
	Если ЧастиИмени.Количество() = 3 Тогда
		ПолноеИмяОбъекта = ЧастиИмени[0] + "." + ЧастиИмени[1];
		Попытка
			Менеджер = МенеджерОбъектаПоИмени(ПолноеИмяОбъекта);
		Исключение
			Менеджер = Неопределено;
		КонецПопытки;
		Если Менеджер = Неопределено Тогда
			ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неправильный формат параметра %1 (передано значение: ""%2"") в %3:
				           |Не существует менеджер объекта ""%4"".'"),
				"ИмяПроцедуры", ИмяПроцедуры, "ОбщегоНазначения.ВыполнитьМетодКонфигурации", ПолноеИмяОбъекта);
		КонецЕсли;
	КонецЕсли;
	
	ИмяМетодаОбъекта = ЧастиИмени[ЧастиИмени.ВГраница()];
	ВременнаяСтруктура = Новый Структура;
	Попытка
		// Проверка того, что ИмяПроцедуры является допустимым идентификатором.
		// Например: МояПроцедура.
		ВременнаяСтруктура.Вставить(ИмяМетодаОбъекта);
	Исключение
		КодОсновногоЯзыка = Метаданные.ОсновнойЯзык.КодЯзыка;
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Безопасное выполнение метода'", КодОсновногоЯзыка),
			УровеньЖурналаРегистрации.Ошибка, , , ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра %1 (передано значение: ""%2"") в %3:
			           |Имя метода ""%4"" не соответствует требованиям образования имен процедур и функций.'"),
			"ИмяПроцедуры", ИмяПроцедуры, "ОбщегоНазначения.ВыполнитьМетодКонфигурации", ИмяМетодаОбъекта);
	КонецПопытки;
	
КонецПроцедуры

// Аналог метода БСП. Возвращает менеджер объекта по имени.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Имя - Строка - имя например, "Справочник", "Справочники", "Справочник.Организации".
//
// Возвращаемое значение:
//  СправочникиМенеджер
//  СправочникМенеджер
//  ДокументыМенеджер
//  ДокументМенеджер
//  ...
//
Функция МенеджерОбъектаПоИмени(Имя)
	Перем КлассОМ, ИмяОМ, Менеджер;
	
	ЧастиИмени = СтрРазделить(Имя, ".");
	
	Если ЧастиИмени.Количество() > 0 Тогда
		КлассОМ = ВРег(ЧастиИмени[0]);
	КонецЕсли;
	
	Если ЧастиИмени.Количество() > 1 Тогда
		ИмяОМ = ЧастиИмени[1];
	КонецЕсли;
	
	Если      КлассОМ = "ПЛАНОБМЕНА"
	 Или      КлассОМ = "ПЛАНЫОБМЕНА" Тогда
		Менеджер = ПланыОбмена;
		
	ИначеЕсли КлассОМ = "СПРАВОЧНИК"
	      Или КлассОМ = "СПРАВОЧНИКИ" Тогда
		Менеджер = Справочники;
		
	ИначеЕсли КлассОМ = "ДОКУМЕНТ"
	      Или КлассОМ = "ДОКУМЕНТЫ" Тогда
		Менеджер = Документы;
		
	ИначеЕсли КлассОМ = "ЖУРНАЛДОКУМЕНТОВ"
	      Или КлассОМ = "ЖУРНАЛЫДОКУМЕНТОВ" Тогда
		Менеджер = ЖурналыДокументов;
		
	ИначеЕсли КлассОМ = "ПЕРЕЧИСЛЕНИЕ"
	      Или КлассОМ = "ПЕРЕЧИСЛЕНИЯ" Тогда
		Менеджер = Перечисления;
		
	ИначеЕсли КлассОМ = "ОБЩИЙМОДУЛЬ"
	      Или КлассОМ = "ОБЩИЕМОДУЛИ" Тогда
		
		Возврат ОбщийМодуль(ИмяОМ);
		
	ИначеЕсли КлассОМ = "ОТЧЕТ"
	      Или КлассОМ = "ОТЧЕТЫ" Тогда
		Менеджер = Отчеты;
		
	ИначеЕсли КлассОМ = "ОБРАБОТКА"
	      Или КлассОМ = "ОБРАБОТКИ" Тогда
		Менеджер = Обработки;
		
	ИначеЕсли КлассОМ = "ПЛАНВИДОВХАРАКТЕРИСТИК"
	      Или КлассОМ = "ПЛАНЫВИДОВХАРАКТЕРИСТИК" Тогда
		Менеджер = ПланыВидовХарактеристик;
		
	ИначеЕсли КлассОМ = "ПЛАНСЧЕТОВ"
	      Или КлассОМ = "ПЛАНЫСЧЕТОВ" Тогда
		Менеджер = ПланыСчетов;
		
	ИначеЕсли КлассОМ = "ПЛАНВИДОВРАСЧЕТА"
	      Или КлассОМ = "ПЛАНЫВИДОВРАСЧЕТА" Тогда
		Менеджер = ПланыВидовРасчета;
		
	ИначеЕсли КлассОМ = "РЕГИСТРСВЕДЕНИЙ"
	      Или КлассОМ = "РЕГИСТРЫСВЕДЕНИЙ" Тогда
		Менеджер = РегистрыСведений;
		
	ИначеЕсли КлассОМ = "РЕГИСТРНАКОПЛЕНИЯ"
	      Или КлассОМ = "РЕГИСТРЫНАКОПЛЕНИЯ" Тогда
		Менеджер = РегистрыНакопления;
		
	ИначеЕсли КлассОМ = "РЕГИСТРБУХГАЛТЕРИИ"
	      Или КлассОМ = "РЕГИСТРЫБУХГАЛТЕРИИ" Тогда
		Менеджер = РегистрыБухгалтерии;
		
	ИначеЕсли КлассОМ = "РЕГИСТРРАСЧЕТА"
	      Или КлассОМ = "РЕГИСТРЫРАСЧЕТА" Тогда
		
		Если ЧастиИмени.Количество() < 3 Тогда
			// Регистр расчета
			Менеджер = РегистрыРасчета;
		Иначе
			КлассПодчиненногоОМ = ВРег(ЧастиИмени[2]);
			Если ЧастиИмени.Количество() > 3 Тогда
				ИмяПодчиненногоОМ = ЧастиИмени[3];
			КонецЕсли;
			Если КлассПодчиненногоОМ = "ПЕРЕРАСЧЕТ"
			 Или КлассПодчиненногоОМ = "ПЕРЕРАСЧЕТЫ" Тогда
				// Перерасчет
				Попытка
					Менеджер = РегистрыРасчета[ИмяОМ].Перерасчеты;
					ИмяОМ = ИмяПодчиненногоОМ;
				Исключение
					Менеджер = Неопределено;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли КлассОМ = "БИЗНЕСПРОЦЕСС"
	      Или КлассОМ = "БИЗНЕСПРОЦЕССЫ" Тогда
		Менеджер = БизнесПроцессы;
		
	ИначеЕсли КлассОМ = "ЗАДАЧА"
	      Или КлассОМ = "ЗАДАЧИ" Тогда
		Менеджер = Задачи;
		
	ИначеЕсли КлассОМ = "КОНСТАНТА"
	      Или КлассОМ = "КОНСТАНТЫ" Тогда
		Менеджер = Константы;
		
	ИначеЕсли КлассОМ = "ПОСЛЕДОВАТЕЛЬНОСТЬ"
	      Или КлассОМ = "ПОСЛЕДОВАТЕЛЬНОСТИ" Тогда
		Менеджер = Последовательности;
	КонецЕсли;
	
	Если Менеджер <> Неопределено Тогда
		Если ЗначениеЗаполнено(ИмяОМ) Тогда
			Попытка
				Возврат Менеджер[ИмяОМ];
			Исключение
				Менеджер = Неопределено;
			КонецПопытки;
		Иначе
			Возврат Менеджер;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не удалось получить менеджер для объекта ""%1""'"), Имя);
	
КонецФункции

#КонецОбласти

#Область УсловныеВызовы

// Аналог метода БСП. Возвращает серверный модуль менеджера по имени объекта.
Функция СерверныйМодульМенеджера(Имя)
	ОбъектНайден = Ложь;
	
	ЧастиИмени = СтрРазделить(Имя, ".");
	Если ЧастиИмени.Количество() = 2 Тогда
		
		ИмяВида = ВРег(ЧастиИмени[0]);
		ИмяОбъекта = ЧастиИмени[1];
		
		Если ИмяВида = ВРег("Константы") Тогда
			Если Метаданные.Константы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыСведений") Тогда
			Если Метаданные.РегистрыСведений.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыНакопления") Тогда
			Если Метаданные.РегистрыНакопления.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыБухгалтерии") Тогда
			Если Метаданные.РегистрыБухгалтерии.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыРасчета") Тогда
			Если Метаданные.РегистрыРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Справочники") Тогда
			Если Метаданные.Справочники.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Документы") Тогда
			Если Метаданные.Документы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Отчеты") Тогда
			Если Метаданные.Отчеты.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Обработки") Тогда
			Если Метаданные.Обработки.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("БизнесПроцессы") Тогда
			Если Метаданные.БизнесПроцессы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ЖурналыДокументов") Тогда
			Если Метаданные.ЖурналыДокументов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Задачи") Тогда
			Если Метаданные.Задачи.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыСчетов") Тогда
			Если Метаданные.ПланыСчетов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыОбмена") Тогда
			Если Метаданные.ПланыОбмена.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовХарактеристик") Тогда
			Если Метаданные.ПланыВидовХарактеристик.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовРасчета") Тогда
			Если Метаданные.ПланыВидовРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ОбъектНайден Тогда
		ВызватьИсключение __СтроковыеФункцииСлужебныйКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Объект метаданных ""%1"" не существует.'"), Имя);
	КонецЕсли;
	
	УстановитьБезопасныйРежим(Истина);
	Модуль = Вычислить(Имя);
	
	Возврат Модуль;
КонецФункции

#КонецОбласти

#Область ХранилищеНастроек

// Аналог метода БСП.
//
Процедура ХранилищеСохранить(МенеджерХранилища, КлючОбъекта, КлючНастроек, Настройки,
			ОписаниеНастроек, ИмяПользователя, ОбновитьПовторноИспользуемыеЗначения)
	
	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек(КлючНастроек), Настройки,
		ОписаниеНастроек, ИмяПользователя);
	
	Если ОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Аналог метода БСП.
//
Функция ХранилищеЗагрузить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию,
			ОписаниеНастроек, ИмяПользователя)
	
	Результат = Неопределено;
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек(КлючНастроек),
			ОписаниеНастроек, ИмяПользователя);
	КонецЕсли;
		
	Если Результат = Неопределено Тогда
		Результат = ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Аналог метода БСП. Возвращает строку ключа настроек, не превышающую допустимую длину 128 символов.
// Если указанная строка превышает 128, тогда вместо символов сверх 96 символов
// добавляется их хеш-сумма по алгоритму MD5 размером 32 символа.
//
// Параметры:
//  Строка - Строка - строка произвольной длины.
//
// Возвращаемое значение:
//  Строка - не более 128 символов.
//
Функция КлючНастроек(Знач Строка)
	Возврат СократитьСтрокуКонтрольнойСуммой(Строка, 128);
КонецФункции

#КонецОбласти

#КонецОбласти

#КонецОбласти // СлужебныеПроцедурыИФункции